<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2011.1.2 (Build 701)" ts="2020-04-10 02:29:23">

<Routine name="FMQLDATA" type="MAC" languagemode="0" timestamp="63266,3996.134921"><![CDATA[
FMQLDATA ;CG/CD - Caregraf - FMQL Data Query Processor; 04/03/2020  11:30
 ;;10.0;FMQLDATA;;April 3rd, 2020
 ;
 ;
 ; FMQL Data Query Processor
 ;
 ; For queries for data. Peer of FMQLSCH
 ;
 ; (c) Caregraf 2010-2020
 ;
 ;
 ;
DESONE(REPLY,PARAMS) ;
 I '$D(PARAMS("TYPE")) D ERRORREPLY^FMQLJSON(REPLY,"Type Not Specified") Q
 I '$D(PARAMS("ID")) D ERRORREPLY^FMQLJSON(REPLY,"ID Not Specified") Q
 ; CNODESTOP defaults to 10 unless set explicitly
 N CNODESTOP S CNODESTOP=$S($D(PARAMS("CNODESTOP")):$G(PARAMS("CNODESTOP")),1:10)
 N NTYPE S NTYPE=$TR(PARAMS("TYPE"),"_",".")
 N TRACK S TRACK("STOPPED")=0
 N FLINF D BLDFLINF^FMQLUTIL(NTYPE,.FLINF,2)
 I $D(FLINF("BAD")) D ERRORREPLY^FMQLJSON(REPLY,FLINF("BAD")) Q
 I '$D(FLINF("GL")) D ERRORREPLY^FMQLJSON(REPLY,"Can Only Describe a Global") Q
 I '$D(@FLINF("ARRAY")@(PARAMS("ID"),0)) D ERRORREPLY^FMQLJSON(REPLY,"No such identifier for type "_PARAMS("TYPE")) Q
 D REPLYSTART^FMQLJSON(REPLY)
 D LISTSTART^FMQLJSON(REPLY,"results") ; TBD: remove for new JSON
 D ONEOFTYPE(REPLY,.FLINF,FLINF("ARRAY"),PARAMS("ID"),CNODESTOP,.TRACK)
 D LISTEND^FMQLJSON(REPLY)
 D:$G(TRACK("STOPPED"))>0 DASSERT^FMQLJSON(REPLY,"fmqlMaxStopped",TRACK("STOPPED"),1)
 D:$D(TRACK("TCONTCNT")) DASSERT^FMQLJSON(REPLY,"fmqlContainsTotal",TRACK("TCONTCNT"),1) 
 ; the query as args
 D DICTSTART^FMQLJSON(REPLY,"fmql")
 D DASSERT^FMQLJSON(REPLY,"OP","DESCRIBE")
 D DASSERT^FMQLJSON(REPLY,"TYPELABEL",FLINF("LABEL"))
 D DASSERT^FMQLJSON(REPLY,"ID",FLINF("EFILE")_"-"_PARAMS("ID"))
 D DASSERT^FMQLJSON(REPLY,"CSTOP",CNODESTOP,1)
 D DICTEND^FMQLJSON(REPLY)
 D REPLYEND^FMQLJSON(REPLY)
 Q
 ;
 ;
 ; 
 ; Describe the last record of a type
 ; 
DESLAST(REPLY,PARAMS) ;
 I '$D(PARAMS("TYPE")) D ERRORREPLY^FMQLJSON(REPLY,"Type Not Specified") Q
 N NTYPE S NTYPE=$TR(PARAMS("TYPE"),"_",".")
 N FLINF D BLDFLINF^FMQLUTIL(NTYPE,.FLINF,0)
 N FAR S FAR=FLINF("ARRAY")
 N LIEN S LIEN=$O(@FAR@("A"),-1)
 S PARAMS("ID")=LIEN
 D DESONE(REPLY,.PARAMS)
 Q 
 ;
 ;
 ;
ALL(REPLY,PARAMS) ;
 N FLINF,BPERR,PFLINF,PID,IENA,LIMIT,OFFSET,NOIDXMX,ORDERBY,AFTERIEN,UPTOIEN,CNODESTOP,TOX,RES,CNT,LIEN,TRACK
 I '$D(PARAMS("TYPE")) D ERRORREPLY^FMQLJSON(REPLY,"Type Not Specified") Q
 S FILE=$TR(PARAMS("TYPE"),"_",".")
 D BLDFLINF^FMQLUTIL(FILE,.FLINF,2)
 I $D(FLINF("BAD")) D ERRORREPLY^FMQLJSON(REPLY,FLINF("BAD")) Q
 I '$D(FLINF("GL")) D  ; Handle Describe or Count of contained nodes.
 . I '$D(PARAMS("IN")) S BPERR="Missing: Contained Node Selection requires 'IN'" Q
 . D PARSEURL^FMQLUTIL(PARAMS("IN"),.PFLINF,.PID)
 . I '$D(PID) S BPERR="Bad Value: 'IN' requires ID" Q
 . I '$D(PFLINF("GL")) S BPERR="Bad Value: 'IN' must be a global type" Q
 . I PFLINF("FILE")'=FLINF("PARENT") S BPERR="Bad Value: CNode parent must be in 'IN'" Q
 . S IENA=$NA(@PFLINF("ARRAY")@(PID,FLINF("PLOCSUB")))
 E  S IENA=""
 I $D(BPERR) D ERRORREPLY^FMQLJSON(REPLY,BPERR) Q
 ; Defaults of -1,0,-1 for no LIMIT, no offset, no max cut off if no IDX, 
 S LIMIT=$S($G(PARAMS("LIMIT"))?0.1"-"1.N:PARAMS("LIMIT"),1:-1)
 S OFFSET=$S($G(PARAMS("OFFSET"))?1.N:PARAMS("OFFSET"),1:0)
 S NOIDXMX=$S($G(PARAMS("NOIDXMX"))?1.N:PARAMS("NOIDXMX"),1:-1)
 S ORDERBY=$G(PARAMS("ORDERBY"))
 S AFTERIEN=$G(PARAMS("AFTERIEN"))  ; float value enforced above this pt
 I AFTERIEN'="" S OFFSET=0  ; Make sure AFTERIEN takes precedence
 S UPTOIEN=$G(PARAMS("UPTOIEN"))
 ; S:UPTOIEN<=AFTERIEN UPTOIEN=""  ; cancels out if UPTO <= AFTER
 ; Forcing default CNODESTOP to be 10
 I PARAMS("OP")="DESCRIBE" S CNODESTOP=$S($D(PARAMS("CNODESTOP")):$G(PARAMS("CNODESTOP")),1:10)
 ; Default value is "" for COUNT
 S TOX=$S((PARAMS("OP")="SELECT"):"D JSEL^FMQLDATA(REPLY,.FLINF,FAR,IEN,.PARAMS)",(PARAMS("OP")="DESCRIBE"):"D JDES^FMQLDATA(REPLY,.FLINF,FAR,IEN,CNODESTOP,.PARAMS,.TRACK)","1":"")
 D REPLYSTART^FMQLJSON(REPLY)
 ; Note get empty results: [] for COUNT 
 D LISTSTART^FMQLJSON(REPLY,"results")
 S RES=$$XONFL^FMQLUTIL(.FLINF,$G(PARAMS("FILTER")),IENA,LIMIT,OFFSET,AFTERIEN,UPTOIEN,ORDERBY,NOIDXMX,TOX,.PARAMS)
 S CNT=$P(RES,":",1)
 S PARAMS("LIEN")=$P(RES,":",2)
 D LISTEND^FMQLJSON(REPLY)
 ; Note: if problem listing (no indexed filter), CNT<0
 I PARAMS("OP")="COUNT" D DASSERT^FMQLJSON(REPLY,"count",CNT)
 D:$D(TRACK("STOPPED")) DASSERT^FMQLJSON(REPLY,"fmqlMaxStopped",TRACK("STOPPED"),1)
 ; TBD: how to record NOIDXMX?
 D DICTSTART^FMQLJSON(REPLY,"fmql")
 D DASSERT^FMQLJSON(REPLY,"OP",PARAMS("OP"))
 D DASSERT^FMQLJSON(REPLY,"TYPELABEL",FLINF("LABEL"))
 D DASSERT^FMQLJSON(REPLY,"TYPE",FLINF("EFILE"))
 I PARAMS("OP")'="COUNT" D
 . D:$D(PARAMS("IN")) DASSERT^FMQLJSON(REPLY,"IN",PARAMS("IN"))
 . I $G(LIMIT)>-1 D DASSERT^FMQLJSON(REPLY,"LIMIT",LIMIT,1)
 . ; TODO: handle alternative of AFTERIEN for OFFSET above and do one or other
 . I $G(PARAMS("AFTERIEN"))'="" D DASSERT^FMQLJSON(REPLY,"AFTERIEN",PARAMS("AFTERIEN"),1)
 . I $G(OFFSET)>0 D DASSERT^FMQLJSON(REPLY,"OFFSET",OFFSET,1)
 . I $G(PARAMS("UPTOIEN")) D DASSERT^FMQLJSON(REPLY,"UPTOIEN",PARAMS("UPTOIEN"),1)
 I $D(PARAMS("FILTER")) D DASSERT^FMQLJSON(REPLY,"FILTER",PARAMS("FILTER"))
 ; Only for DESCRIBE
 I $D(CNODESTOP) D DASSERT^FMQLJSON(REPLY,"CSTOP",CNODESTOP,1)
 D DICTEND^FMQLJSON(REPLY)
 D REPLYEND^FMQLJSON(REPLY)
 Q
 ;
 ;
 ; Build JSON for one selection
 ; - FAR = FLINF("ARRAY") for Global; FAR = Qualified location for CNode
 ; Note: supports only top level CNodes
 ; Note: "g"]"H" in MUMPS ie. lower case follows upper case. This means
 ;       selection order is case sensitive. This may be unexpected.
 ; 
 ; Note: MAY DEPRECATE AS SBYPRED is more useful, DESCRIBE CSTOP 0 is succinct enough
 ; or expand to take a list of predicates.
 ; 
 ; 
JSEL(REPLY,FLINF,FAR,IEN,PARAMS) ;
 D DICTSTART^FMQLJSON(REPLY)
 ; FID=IEN for Globals. Only qualify for CNodes
 ; - replace for unusual IENS in .11 etc.
 N FID S FID=$S('$D(FLINF("GL")):IEN_"_"_$QS(FAR,$QL(FAR)-1),1:IEN)
 D IDFIELDS(REPLY,.FLINF,FAR,IEN,FID,"id")
 I $D(PARAMS("FIELD")) D
 . N FDINF D BLDFDINF^FMQLUTIL(.FLINF,PARAMS("FIELD"),.FDINF)
 . Q:$D(FDINF("BAD"))  ; TBD: centralize
 . Q:FDINF("TYPE")=9  ; Don't allow CNode selection this way. Force "IN".
 . Q:FDINF("TYPE")=11  ; For now, don't allow .001 as most not explicitly exposed
 . D ONEFIELD(FAR,IEN,.FDINF)
 D DICTEND^FMQLJSON(REPLY)
 Q
 ;
 ;
 ; Same as JSEL except returns full description
JDES(REPLY,FLINF,FAR,IEN,CNODESTOP,PARAMS,TRACK) ;
 ; Last Subscript for CNode
 N ID S ID=$S('$D(FLINF("GL")):IEN_"_"_$QS(FAR,$QL(FAR)-1),1:IEN)
 D ONEOFTYPE(REPLY,.FLINF,FAR,ID,CNODESTOP,.TRACK)
 Q
 ;
 ;
ONEOFTYPE(REPLY,FLINF,FAR,FID,CNODESTOP,TRACK,EMBEDDED) ;
 N ID S ID=$P(FID,"_") ; Allow for CNode
 Q:$P($G(@FAR@(ID,0)),"^")=""  ; All need an .01 field
 N RSTOPPED,OO1FDINF,OO1ID
 D DICTSTART^FMQLJSON(REPLY)
 N FIELD S FIELD=0 F  S FIELD=$O(FLINF("FDINFS",FIELD)) Q:FIELD=""  D
 . N FDINF M FDINF=FLINF("FDINFS",FIELD)
 . Q:$D(FDINF("BAD"))
 . I FDINF("TYPE")=9 D  ; TBD: loop with walkers and B Index
 . . Q:'$D(@FAR@(ID,FDINF("LOCSUB")))
 . . N NFAR S NFAR=$NA(@FAR@(ID,FDINF("LOCSUB")))
 . . ; Pharma+ case: CNode location but no list params in 0 node
 . . Q:$P($G(@NFAR@(0)),"^",4)=""
 . . N FMCNT S FMCNT=$P($G(@NFAR@(0)),"^",4)
 . . S:FMCNT'=+FMCNT FMCNT=-1  ; Invalid
 . . N BFLINF M BFLINF=FDINF("BFLINF")
 . . ; Ignore if over CNODESTOP
 . . N CCNT S CCNT=0
 . . N BID S BID=0 F  S BID=$O(@NFAR@(BID)) Q:BID'=+BID!(CCNT=CNODESTOP)  S CCNT=CCNT+1
 . . I CCNT'=CNODESTOP  D
 . . . Q:CCNT=0  ; Don't mark empty bnodes (Pharma et al)
 . . . S TRACK("TCONTCNT")=$G(TRACK("TCONTCNT"))+CCNT  ; prep for v3.1 CSTOP wider
 . . . N ISLIST S ISLIST=$S(BFLINF("NOFIELDS")=1:1,1:0)
 . . . D BNLISTSTART^FMQLJSON(REPLY,BFLINF("EFILE"),FDINF("LABEL"),FIELD,ISLIST)
 . . . ; No need for NFAR or BFLINF if FLINF (even if CNode) supports ARRAY
 . . . N BID S BID=0 F  S BID=$O(@NFAR@(BID)) Q:BID'=+BID  D
 . . . . D ONEOFTYPE(REPLY,.BFLINF,NFAR,BID_"_"_FID,CNODESTOP,.TRACK,1)
 . . . D BNLISTEND^FMQLJSON(REPLY)
 . . E  D
 . . . N PRED S PRED=FDINF("PRED")
 . . . S RSTOPPED(PRED,"COUNT")=FMCNT  ; could be 0 even when entries
 . . . S RSTOPPED(PRED,"EFILE")=BFLINF("EFILE")
 . E  I FDINF("FIELD")=.001 M OO1FDINF=FDINF S OO1ID=ID
 . E  D
 . . I FDINF("FIELD")=.01  D  ; In addition to treating as one field
 . . . D:$D(EMBEDDED) DASSERT^FMQLJSON(REPLY,"ien",ID)
 . . . D:'$D(EMBEDDED) IDFIELDS(REPLY,.FLINF,FAR,ID,FID,"_id",1)
 . . . D:$D(OO1FDINF) OO1FIELD(OO1ID,.OO1FDINF)  ; come after ID FIELDS
 . . D ONEFIELD(FAR,ID,.FDINF)
 ; TBD: properly count SLABS ala other CNodes
 I FLINF("FILE")="63.04",CNODESTOP>0,^TMP($J,"NS")="VS" D BLDBNODES^FMQLSLAB(FAR,FID)
 D:$D(RSTOPPED) TRACKSTOPS(.TRACK,.RSTOPPED)
 D DICTEND^FMQLJSON(REPLY)
 Q
 ; 
 ;
 ; Track STOPs global to reply (STOPPED) and per result (RSTOPPED)
 ; 
TRACKSTOPS(TRACK,RSTOPPED)
 D DICTSTART^FMQLJSON(REPLY,"fmqlStopped")
 N CSTPP S CSTPP="" F  S CSTPP=$O(RSTOPPED(CSTPP)) Q:CSTPP=""  D
 . D DICTSTART^FMQLJSON(REPLY,CSTPP)
 . N SCOUNT S SCOUNT=RSTOPPED(CSTPP,"COUNT")
 . S:SCOUNT>$G(TRACK("STOPPED")) TRACK("STOPPED")=SCOUNT
 . ; 'count' is FMCNT and so can be 0 even if there are entries
 . D DASSERT^FMQLJSON(REPLY,"count",SCOUNT,1)  ; made valid or -1 above 
 . D DASSERT^FMQLJSON(REPLY,"sub_type",RSTOPPED(CSTPP,"EFILE"))
 . D DICTEND^FMQLJSON(REPLY)
 D DICTEND^FMQLJSON(REPLY)
 Q
 ;
 ;
 ; Identifier fields are special and derived from resolving the .01 field.
 ;
IDFIELDS(REPLY,FLINF,FAR,ID,FID,IDPROP,ADDTYPE) ;
 ; TBD: is this redundant?
 N O1L S O1L=$P($G(@FAR@(ID,0)),"^")
 ; All records should have a value for .01. TBD: check above.
 ; Saw bug in RPMS (9001021) where index has "^" as name and 0 is "^".
 Q:O1L=""
 N FDINF D BLDFDINF^FMQLUTIL(.FLINF,.01,.FDINF)  ; Assume ok. FLINF checked
 N PVALUE S PVALUE=$TR(FLINF("FILE"),".","_")_"-"_FID
 D DASSERT^FMQLJSON(REPLY,IDPROP,PVALUE)
 N EVALUE,BAD S EVALUE=$$GETEVAL^FMQLUTIL(.FDINF,O1L,.BAD)
 D:'$D(BAD) DASSERT^FMQLJSON(REPLY,"label",EVALUE)
 ; TODO v3.1 - may remove and rely just on TYPELABEL in reply
 I $D(ADDTYPE)  D
 . N TYP S TYP=FLINF("LABEL")_"-"_FLINF("EFILE")
 . D DASSERT^FMQLJSON(REPLY,"type",TYP)
 Q
 ;
 ;
 ; Build JSON for one non-CNode Field
 ;
 ; Assume: FDINF is good
 ;
ONEFIELD(FAR,ID,FDINF) ;
 Q:FDINF("TYPE")=6  ; Computed - includes .001
 Q:'$D(@FAR@(ID,FDINF("LOCSUB")))
 I FDINF("TYPE")=5 D
 . ; Pharma+ case: WP location but no entries (ala special case for 9)
 . ; TBD: "" only entry. Seen in RAD, P/H. 
 . Q:'$D(@FAR@(ID,FDINF("LOCSUB"),1))
 . D WPASTART^FMQLJSON(REPLY,FDINF("PRED"))
 . F WPR=1:1 Q:'$D(@FAR@(ID,FDINF("LOCSUB"),WPR))  D
 . . D WPALINE^FMQLJSON(REPLY,@FAR@(ID,FDINF("LOCSUB"),WPR,0))
 . D WPAEND^FMQLJSON(REPLY)
 . Q
 ; Check as sub values may exist but not the value indicated. 
 ; Saw WP field's location overloaded for another field 
 ; (RPMS:811.8 vs VistA's which is ok)
 Q:$G(@FAR@(ID,FDINF("LOCSUB")))=""
 N LOCSUB S LOCSUB=@FAR@(ID,FDINF("LOCSUB"))
 ; For $E values, don't just take the $E limit.
 N IVALUE S IVALUE=$S($D(FDINF("LOCPOS")):$P(LOCSUB,"^",FDINF("LOCPOS")),1:LOCSUB) Q:IVALUE=""
 N BAD,PFLSUM
 N EVALUE S EVALUE=$$GETEVAL^FMQLUTIL(.FDINF,IVALUE,.BAD)
 Q:$D(BAD)  ; will include a -1 for invalid date
 I FDINF("TYPE")=1 D DATEAST^FMQLJSON(REPLY,FDINF("PRED"),EVALUE) Q 
 I FDINF("TYPE")=7 D PTRAST^FMQLJSON(REPLY,FDINF("PRED"),FDINF("PEFILE")_"-"_IVALUE,EVALUE) Q
 I FDINF("TYPE")=8 D PTRAST^FMQLJSON(REPLY,FDINF("PRED"),FDINF("PLOCE",$P(IVALUE,";"))_"-"_$P(IVALUE,";"),EVALUE) Q
 I FDINF("TYPE")=12 D BOOLAST^FMQLJSON(REPLY,FDINF("PRED"),EVALUE) Q
 ; 2, 3, 4 
 D DASSERT^FMQLJSON(REPLY,FDINF("PRED"),EVALUE)
 Q
 ;
 ; .001 is special: its value is the IEN of a record. Nothing is stored inside the file.
 ; Only some values (Date, Pointer) should be first class fields. .001 stored and then
 ; asserted after IDFIELDs
 ;
OO1FIELD(ID,FDINF)  ;
 N PFLINF,PVALUE,PLABEL,EVALUE
 Q:FDINF("TYPE")'=11
 ; IEN is a pointer
 I $D(FDINF("PFILE")) D
 . S FDINF("TYPE")=7  ; Overload .001 defn pointer: assume cannot be vptr
 . N BAD
 . S EVALUE=$$GETEVAL^FMQLUTIL(.FDINF,ID,.BAD)
 . Q:$D(BAD)
 . D PTRAST^FMQLJSON(REPLY,FDINF("PRED"),FDINF("PEFILE")_"-"_ID,$P(EVAL,"::"))
 ; IEN is a date - TODO: issue of DX vs D?
 E  I FDINF("FLAGS")["D" D
 . S FDINF("TYPE")=1
 . N BAD
 . S EVALUE=$$GETEVAL^FMQLUTIL(.FDINF,ID,.BAD)
 . Q:$D(BAD)
 . D DATEAST^FMQLJSON(REPLY,FDINF("PRED"),EVALUE)
 ; Assuming .001 can't be coded value so no need to pass IVALUE
 S FDINF("TYPE")=11  ; reset
 Q
 ;
 ;
 ; CNTREFS
 ;
 ; Ex/ COUNTREFS 2-9 - count the referrers to entry 9 in file 2
 ;
 ; Unlike generic graph stores that are specialized for 
 ; "SELECT * FILTER(*=2-9)", the strongly typed FileMan
 ; has no central index of referrents. As a result, such
 ; a general query is slow and unnatural. However, a querier
 ; still needs to know about the graph a file entry appears in.
 ; 
 ; This operation is a compromise. It counts references from
 ; appropriately indexed referrers. These counts provide a
 ; starting off point for exploring a file entry's graph.
 ;
 ; In: type, id
 ; Out: total, count per file/field combo
 ;
 ; NB: NOIDXMX is key here. If set too low then certain referrer
 ; grabs will go far too long. This is set in the Python query
 ; processor.
 ;
CNTREFS(REPLY,PARAMS) ;
 I '$D(PARAMS("TYPE")) D ERRORREPLY^FMQLJSON(REPLY,"Type Not Specified") Q
 I '$D(PARAMS("ID")) D ERRORREPLY^FMQLJSON(REPLY,"ID Not Specified") Q
 N NTINF D BLDFLINF^FMQLUTIL(PARAMS("TYPE"),.NTINF,0)
 I $D(NTINF("BAD")) D ERRORREPLY^FMQLJSON(REPLY,NTINF("BAD")) Q
 I '$D(@NTINF("ARRAY")@(PARAMS("ID"),0)) D ERRORREPLY^FMQLJSON(REPLY,"No such identifier for type "_PARAMS("TYPE")) Q
 N TARGET S TARGET=NTINF("EFILE")_"-"_PARAMS("ID")
 ; NOIDXMX is important. Otherwise the unimportant will take time.
 N NOIDXMX S NOIDXMX=$G(PARAMS("NOIDXMX"))
 S:(NOIDXMX'=+NOIDXMX) NOIDXMX=-1
 N TCNT S TCNT=0
 D REPLYSTART^FMQLJSON(REPLY)
 D LISTSTART^FMQLJSON(REPLY,"results")
 N RFL ; Order referrer types by name
 N FILE S FILE="" F  S FILE=$O(^DD(NTINF("FILE"),0,"PT",FILE)) Q:FILE'=+FILE  D
 . N FLINF D BLDFLINF^FMQLUTIL(FILE,.FLINF,0)
 . Q:($D(FLINF("BAD"))!$D(FLINF("PARENT")))
 . ; Q:FLINF("FMSIZE")<1 surely empty files aren't costly
 . S RFL(FLINF("LABEL"),FILE)=""
 ; Walk referring files in order (know ok as orderer catches bad files)
 N FILELABEL S FILELABEL="" F  S FILELABEL=$O(RFL(FILELABEL)) Q:FILELABEL=""  D
 . N FILE S FILE="" F  S FILE=$O(RFL(FILELABEL,FILE)) Q:FILE=""  D
 . . N FLINF D BLDFLINF^FMQLUTIL(FILE,.FLINF,0)
 . . N FIELD S FIELD="" F  S FIELD=$O(^DD(NTINF("FILE"),0,"PT",FILE,FIELD)) Q:FIELD'=+FIELD  D
 . . . N FDINF D BLDFDINF^FMQLUTIL(.FLINF,FIELD,.FDINF)
 . . . I $D(FDINF("BAD")) Q
 . . . I FDINF("TYPE")'=7 Q  ; PTR only for now (no vptr)
 . . . N FLT S FLT=FIELD_"="_NTINF("FILE")_"-"_PARAMS("ID")
 . . . N RES S RES=$$XONFL^FMQLUTIL(.FLINF,FLT,"",-1,0,"","","",NOIDXMX,"")
 . . . N CNT S CNT=$P(RES,":",1)
 . . . Q:CNT=-1  ; means no idx max exceeded.
 . . . S:CNT'=+CNT CNT=0
 . . . Q:CNT<1
 . . . D DICTSTART^FMQLJSON(REPLY)
 . . . N FLDLABEL S FLDLABEL=FDINF("LABEL") ; Add predicate
 . . . ; Old style names (file, field etc) should be reconsidered (TODO)
 . . . D DASSERT^FMQLJSON(REPLY,"file",FLINF("EFILE"))
 . . . D DASSERT^FMQLJSON(REPLY,"fileLabel",FILELABEL)
 . . . D DASSERT^FMQLJSON(REPLY,"field",FIELD)
 . . . ; NOT made unique to file as too costly for larger file's referenced - pred may lack qualifier
 . . . D DASSERT^FMQLJSON(REPLY,"fieldLabel",$$FIELDTOPRED^FMQLUTIL(FDINF("LABEL")))
 . . . D DASSERT^FMQLJSON(REPLY,"count",CNT,1)
 . . . D DICTEND^FMQLJSON(REPLY)
 . . . S TCNT=TCNT+CNT
 D LISTEND^FMQLJSON(REPLY)
 D DASSERT^FMQLJSON(REPLY,"total",TCNT,1)
 D DICTSTART^FMQLJSON(REPLY,"fmql")
 D DASSERT^FMQLJSON(REPLY,"OP","COUNT REFS")
 D DASSERT^FMQLJSON(REPLY,"TYPELABEL",NTINF("LABEL"))
 D DASSERT^FMQLJSON(REPLY,"ID",TARGET)
 D DICTEND^FMQLJSON(REPLY)
 D REPLYEND^FMQLJSON(REPLY)
 Q
 ;
]]></Routine>


<Routine name="FMQLFILT" type="MAC" languagemode="0" timestamp="63152,35757.448477"><![CDATA[
FMQLFILT ;CG/CD - Caregraf - FMQL Query Processor; 04/03/2020  11:30
 ;;10.0;FMQLFILT;;April 3rd, 2020
 ;
 ;
 ; FMQL Filters
 ; 
 ; Parse and Apply filters
 ; 
 ; (c) Caregraf 2010-2020
 ;
 ; TBD:
 ; - remove support for &: only &&
 ; - force all values to be quoted. Must be 'X' or "X"
 ; - remove need for \& inside quotes
 ;
 ;
 ; Simple & sequence of X op Y and bound(X)
 ;
 ; Note: must be careful with MUMPS evaluation precedence - lot's of brackets
 ;
FLTTOM(FLINF,FLT,IENA) ;
 Q:$D(FLINF("BAD")) "0"
 N FLTP,FLTN,TST S FLTN=1,TST="("
 ; V0.9: temp support for & while allowing missing quotes
 S FLT=$$ESCAND(FLT) ; Escape & inside
 ; V0.9. Moving to &&. Still support & for now
 N AND S AND=$S(FLT["&&":"&&","1":"&")
 F  S FLTP=$P(FLT,AND,FLTN) Q:FLTP=""  D
 . I FLTN>1 S TST=TST_"&"
 . S FLTN=FLTN+1
 . I $F(FLTP,"bound") S TST=TST_$$FLTBOUNDTOM(.FLINF,FLTP,$G(IENA))
 . E  S TST=TST_$$FLTLRTOM(.FLINF,$TR(FLTP,$C(0),"&"),$G(IENA))
 Q TST_")"
 ; 
 ;
 ; Create executable expression from FMQL "X OP Y" filter element
 ;
 ; Arguments:
 ; - FLINF
 ; - FLT: the LVAL OP RVALUE filter
 ; - IENA mandatory for CNodes
 ; 
FLTLRTOM(FLINF,FLT,IENA) ;
 N OP S OP=$S($F(FLT,"="):"=",$F(FLT,"["):"[",$F(FLT,">"):">",$F(FLT,"<"):"<",1:"")
 Q:OP="" "0"
 N FIELD S FIELD=$P(FLT,OP)
 N FDINF D BLDFDINF^FMQLUTIL(.FLINF,FIELD,.FDINF)
 Q:$D(FDINF("BAD")) "0"
 ; Take val from single quoted values after op
 N VAL S VAL=$P(FLT,OP,2)
 ; TBD: move to mandatory use of ' for values. Opt now for v0.8 compat
 ; Not using pattern. Allow quotes inside. Just catch at end.
 N QUOTE S QUOTE=$S($E(VAL,1)="'":"'",1:"""")
 ; Allow no quotes or ' or "
 I $E(VAL,1)=QUOTE,$E(VAL,$L(VAL))=QUOTE S VAL=$E(VAL,2,$L(VAL)-1)
 I OP=">",VAL'=+VAL S OP="]"  ; use order operator for non numeric > thans. TBD: what of <?
 Q:FDINF("TYPE")=8 "0"  ; not supporting VPTR yet
 S:FDINF("TYPE")=7 VAL=$P(VAL,"-",2)  ; remove file type if pointer
 S:FDINF("TYPE")=1 VAL=$$MAKEFMDATE^FMQLUTIL(VAL)  ; from FMQL to FM date
 N FAR S FARNA=$S($D(FLINF("GL")):$NA(FLINF("ARRAY")),"1":$NA(IENA))
 S LVAL="$P($G(@"_FARNA_"@(IEN,"""_FDINF("LOCSUB")_""")),""^"","_FDINF("LOCPOS")_")"
 ; One special case: remove file type if pointer. Second is date. Will do later.
 N MFLT S MFLT="("_LVAL_OP_""""_VAL_""")"
 Q MFLT
 ;
 ;
 ; Key aspect of FileMan (and sparcely populated stores in general). Optional
 ; fields don't get default values. One key filter is to check if a field has
 ; a value - is a field 'bound'?
 ;
FLTBOUNDTOM(FLINF,FLT,IENA) ;
 N FIELD S FIELD=$P($P(FLT,"(",2),")")
 N FDINF D BLDFDINF^FMQLUTIL(.FLINF,FIELD,.FDINF)
 Q:$D(FDINF("BAD")) "0"
 N NOT S NOT=$S($F(FLT,"!"):"",1:"'")
 N FAR S FARNA=$S($D(FLINF("GL")):$NA(FLINF("ARRAY")),"1":$NA(IENA))
 ; CNode special. Bound if entries: ^LR(4,"CH",0)="^63.04D^38^38"
 ; Assume if 0 filled in then there are.
 Q:FDINF("TYPE")=9 "($G(@"_FARNA_"@(IEN,"""_FDINF("LOCSUB")_""",0))"_NOT_"="""")"
 Q "($P($G(@"_FARNA_"@(IEN,"""_FDINF("LOCSUB")_""")),""^"","_FDINF("LOCPOS")_")"_NOT_"="""")"
 ;
 ;
 ; Return Index of the filter. Without this, every filtered query becomes 
 ; a linear search.
 ;
 ; Note: Globals only
 ;
FLTIDX(FLINF,FLT,IDXA,IDXSTART) ;
 Q:'$D(FLINF("GL"))
 N FLTP,FLTN
 S FLTN=1,IDXA="",IDXSTART=""
 S FLT=$$ESCAND(FLT) ; Escape inner &
 F  S FLTP=$P(FLT,"&",FLTN) Q:((FLTP="")!(IDXA'=""))  D
 . S FLTN=FLTN+1
 . Q:$F(FLTP,"bound")
 . N OP S OP=$S($F(FLT,"="):"=",$F(FLT,">"):">",1:"") Q:OP=""  ; =, > are only options
 . N FIELD S FIELD=$P(FLTP,OP)
 . N FDINF D BLDFDINF^FMQLUTIL(.FLINF,FIELD,.FDINF)
 . Q:$D(FDINF("BAD"))  ; Bad field
 . Q:FDINF("TYPE")=8  ; No "V" - not supporting variable pointers for now
 . N IDX S IDX=$$FIELDIDX^FMQLUTIL(FLINF("FILE"),FIELD)  ; TBD: move to meta
 . I IDX'="" D
 . . N ID S ID=$P(FLTP,OP,2)
 . . S ID=$TR(ID,$C(0),"&") ; put back escaped and
 . . N QUOTE S QUOTE=$S($E(ID,1)="'":"'",1:"""")
 . . ; Allow no quotes or ' or ". V0.9, force one or the other
 . . I $E(ID,1)=QUOTE,$E(ID,$L(ID))=QUOTE S ID=$E(ID,2,$L(ID)-1)
 . . Q:ID=""  ; Go to next possibility
 . . ; S:FDINF("TYPE")=4 ID=$E(ID,1,30) ; Indexes only count the first 30
 . . S:FDINF("TYPE")=7 ID=$P(ID,"-",2) ; FileMan internal form
 . . Q:ID=""  ; Not valid pointer. Catch of IDXA will be invalid
 . . S:FDINF("TYPE")=1 ID=$$MAKEFMDATE^FMQLUTIL(ID)  ; Internal date
 . . Q:ID=""  ; Not valid date
 . . I OP="=" S IDXA=FLINF("GL")_""""_IDX_""","""_ID_""")" Q
 . . ; Must be > as only option left 
 . . ; Special: float form that holds hhmmss gives problem as
 . . ; MUMPS $O won't navigate floats ie/ get the next in order.
 . . ; Must reduce date to base and get the extact next in order
 . . ; from that.
 . . S IDXA=FLINF("GL")_""""_IDX_""")"
 . . S IDXSTART=$S(FDINF("TYPE")=1:$O(@IDXA@($E(ID,1,7))),1:ID)
 Q
 ;
 ; Manual Index finding - TBD: move to own file ala manual SSAM
MFLTIDX(FLINF,FLT,IDXA,IDXSTART) ;
 I FLINF("FILE")="100" D OFLTIDX(.FLINF,FLT,.IDXA,.IDXSTART) Q
 D RXFLTIDX(.FLINF,FLT,.IDXA,.IDXSTART)
 Q
 ;
OFLTIDX(FLINF,FLT,IDXA,IDXSTART) ;
 N FLTP,FLTN
 Q:FLINF("FILE")'="100"
 S IDXA="",IDXSTART=""
 S FLTN=1,IDXA=""
 F  S FLTP=$P(FLT,"&",FLTN) Q:FLTP=""  D
 . S FLTN=FLTN+1
 . I $F(FLTP,"bound") Q
 . N OP S OP=$S($F(FLT,"="):"=",1:"")
 . Q:OP=""
 . Q:OP'="="
 . N FIELD S FIELD=$P(FLTP,OP)
 . Q:FIELD'=".02"
 . I $P($P(FLTP,"=",2),"-")'="2" Q  ; must be patient filter for now
 . N PID S PID=$P($P(FLTP,"=",2),"-",2)
 . S IDXA="^OR(100,""AR"","""_PID_";DPT("")" Q
 Q
 ;
RXFLTIDX(FLINF,FLT,IDXA,IDXSTART) ;
 ; Rely on ^PS(55,PID,"P","A"... hidden RX index in the "P" multiple of 55
 N FLTP,FLTN
 Q:FLINF("FILE")'="52"
 S IDXA="",IDXSTART=""
 S FLTN=1,IDXA=""
 F  S FLTP=$P(FLT,"&",FLTN) Q:FLTP=""  D
 . S FLTN=FLTN+1
 . I $F(FLTP,"bound") Q
 . N OP S OP=$S($F(FLT,"="):"=",1:"")
 . Q:OP=""
 . Q:OP'="="
 . N FIELD S FIELD=$P(FLTP,OP)
 . Q:FIELD'="2"
 . I $P($P(FLTP,"=",2),"-")'="2" Q  ; must be patient filter
 . N PID S PID=$P($P(FLTP,"=",2),"-",2)
 . S IDXA="^PS(55,"_PID_",""P"",""A"")" Q
 Q
 ;
 ; Escape & as long as support quoteless assertions
 ; FLT piece with form X\&Y
 ; Crude: some combinations (leading, trailing, multiple) won't work
 ; Will go when escaping becomes unnecessary in V1.0
ESCAND(FLTE) ;
 N FLT S FLT=""
 N BIT,I S I=1
 F  S BIT=$P(FLTE,"\&",I) Q:BIT=""  D
 . S:I>1 FLT=FLT_$C(0)
 . S I=I+1
 . S FLT=FLT_BIT
 S:FLT="" FLT=EFLT
 Q FLT
 ;
]]></Routine>


<Routine name="FMQLJSON" type="MAC" languagemode="0" timestamp="63152,35801.939237"><![CDATA[
FMQLJSON ;CG/CD - Caregraf - FMQL Query Processor; 04/03/2020  11:30
 ;;10.0;FMQLJSON;;April 3rd, 2020
 ;
 ;
 ; FMQL JSON Builder
 ; 
 ; A "class" for building JSON responses
 ; 
 ; Caregraf 2010-2020
 ;
ERRORREPLY(REPLY,MSG) ;
 D REPLYSTART^FMQLJSON(.REPLY)
 D DASSERT^FMQLJSON(.REPLY,"error",MSG)
 D REPLYEND^FMQLJSON(.REPLY)
 Q
REPLYSTART(JSON) ;
 S @JSON@("INDEX")=0
 S @JSON@("OFFSET")=1
 S @JSON@(0)=""
 D PUTDATA(JSON,"{")
 S @JSON@("LSTLVL")=0
 S @JSON@("LSTLVL",0)=""
 Q
LISTSTART(JSON,LABEL) ;
 D CONTSTART(JSON,""""_LABEL_""":[")
 Q
DICTSTART(JSON,LABEL) ;
 I $D(LABEL) D CONTSTART(JSON,""""_LABEL_""":{") Q
 D CONTSTART(JSON,"{")
 Q
 ;
 ; List or Dict: both are containers that increase the 'level'. 
 ; Level monitoring comes from JSON's need for commas between multiples, something XML avoids
CONTSTART(JSON,MARK) ;
 D PUTDATA(JSON,@JSON@("LSTLVL",@JSON@("LSTLVL")))
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))=","
 S @JSON@("LSTLVL")=@JSON@("LSTLVL")+1
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))=""
 D PUTDATA(JSON,MARK)
 Q
 ;
PTRAST(JSON,PRED,PID,PLABEL)
 N PVALUE S PVALUE="{""id"":"""_PID_""",""label"":"""_$$JSONSTRING(PLABEL)_"""}"
 D DASSERT(JSON,PRED,PVALUE,1)
 Q
 ;
 ; Expects only valid full day or day-time
 ; 
DATEAST(JSON,PRED,VALUE)
 N DTTYP S DTTYP=$S($L(VALUE)=10:"xsd:date",1:"xsd:dateTime")
 N DTVALUE S DTVALUE="{""value"":"""_VALUE_""",""type"":"""_DTTYP_"""}"
 D DASSERT(JSON,PRED,DTVALUE,1)
 Q
 ;
BOOLAST(JSON,PRED,VALUE)
 N BLVALUE S BLVALUE="{""value"":"""_VALUE_""",""type"":""xsd:boolean""}"
 D DASSERT(JSON,PRED,VALUE,1)
 Q
 ;
DASSERT(JSON,LVALUE,RVALUE,NQUOTE) ;
 D PUTDATA(JSON,@JSON@("LSTLVL",@JSON@("LSTLVL")))
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))="," ; if next el then put a col before it
 I $G(NQUOTE)'=1 D PUTDATA(JSON,""""_LVALUE_""":"""_$$JSONSTRING(RVALUE)_"""") Q
 D PUTDATA(JSON,""""_LVALUE_""":"_RVALUE) 
 Q
 ; 
WPASTART(JSON,LVALUE) ;
 D PUTDATA(JSON,@JSON@("LSTLVL",@JSON@("LSTLVL")))
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))="," ; if next el then put a col before it
 S @JSON@("LSTLVL")=@JSON@("LSTLVL")+1
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))=""
 D PUTDATA(JSON,""""_LVALUE_""":""")
 Q
 ;
 ; May add $$HTML^DILF escape
WPALINE(JSON,LINE) ;
 D PUTDATA(JSON,@JSON@("LSTLVL",@JSON@("LSTLVL")))
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))="\n" ; if next el then put a col before it
 D PUTDATA(JSON,$$JSONSTRING(LINE))
 Q
WPAEND(JSON) ;
 D CONTEND(JSON,"""")
 Q
 ;
 ; ISL is NOT being used now
 ;
BNLISTSTART(JSON,BFL,BFDLBL,BFD,ISL) ; 
 D PUTDATA(JSON,@JSON@("LSTLVL",@JSON@("LSTLVL")))
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))=","
 S @JSON@("LSTLVL")=@JSON@("LSTLVL")+1
 S @JSON@("LSTLVL",@JSON@("LSTLVL"))=""
 D PUTDATA(JSON,""""_$$FIELDTOPRED^FMQLUTIL(BFDLBL)_""":[")
 Q
BNLISTEND(JSON) ;
 D CONTEND(JSON,"]")
 Q
DICTEND(JSON) ;
 D CONTEND(JSON,"}")
 Q
LISTEND(JSON) ;
 D CONTEND(JSON,"]")
 Q
CONTEND(JSON,MARKUP) ;
 D PUTDATA(JSON,MARKUP)
 K @JSON@("LSTLVL",@JSON@("LSTLVL"))
 S @JSON@("LSTLVL")=@JSON@("LSTLVL")-1
 Q
REPLYEND(JSON) ;
 D PUTDATA(JSON,"}")
 K @JSON@("LSTLVL")
 K @JSON@("INDEX")
 K @JSON@("OFFSET")
 Q
PUTDATA(JSON,DATA) ;
 S NODESIZE=201 ; TBD: lower (10) slows replies. But little advan over 1024, even slows the small.
 N LEN S LEN=$L(DATA)
 N NUM S NUM=LEN
 N OFFSET S OFFSET=@JSON@("OFFSET")
 N INDEX S INDEX=@JSON@("INDEX")
 I NUM+OFFSET-1>NODESIZE D
 . S NUM=NODESIZE-OFFSET+1
 . S @JSON@(@JSON@("INDEX"))=@JSON@(@JSON@("INDEX"))_$E(DATA,1,NUM)
 . S @JSON@("OFFSET")=1 S @JSON@("INDEX")=INDEX+1 S @JSON@(@JSON@("INDEX"))=""
 . D PUTDATA(JSON,$E(DATA,NUM+1,LEN))
 . Q
 E  D
 . S @JSON@(@JSON@("INDEX"))=@JSON@(@JSON@("INDEX"))_DATA
 . S @JSON@("OFFSET")=@JSON@("OFFSET")+NUM
 . Q
 Q
 ;
 ;
 ; Rules for JSON Values from www.json.org
 ; A JSON Value can be a string in double quotes, number, array, object (dictionary), 
 ; true|false|null.
 ;
 ; For string values
 ; 1. CTRL characters (0-31 except the escaped noted below) are not allowed as themselves.
 ; GT/M using UTF2HEX, Cache using ZHEX - REMOVED IN V2 to avoid warning on GT/M.
 ; 2. Escape the following with a \
 ; - QUOTE 34 "
 ; - Backslash 92 \
 ; - BS 8 ^H Backspace, works on HP terminals/computers (b)
 ; - HT 9 ^I Horizontal tab, move to next tab stop (t)
 ; - LF 10 ^J Line Feed (n)
 ; - FF 12 ^L Form Feed, page eject (f) 
 ; - CR 13 ^M Carriage Return (r)
 ; 3. From 128->255+. Turn to \u0080 on. Note that "M" or "ASCII"
 ; is just to 255.
 ;
 ; Note: 
 ; - If character set is utf-8, then $L(($C(256))=1 (cheap check).
 ; - not escaping forward slash (47). JSON standard seems to say yes but few encoders
 ;   do this and all decoders accept it as is.
 ;
JSONSTRING(IN) N ASCII,II,HEX,HH,OUT
 S ASCII(8)="\b"
 S ASCII(9)="\t"
 S ASCII(10)="\n"
 S ASCII(12)="\f"
 ; Changed to \n
 S ASCII(13)="\n"
 S ASCII(34)="\"""
 S ASCII(92)="\\"
 S OUT="" F II=1:1:$L(IN) D
 . S ASCII=$A(IN,II)
 . I $G(ASCII(ASCII))'="" S OUT=OUT_ASCII(ASCII) Q
 . I ASCII>31,ASCII<127 S OUT=OUT_$C(ASCII) Q
 . S HEX="" F HH=1:1:4 S HEX=$E("0123456789abcdef",ASCII#16+1)_HEX,ASCII=ASCII\16
 . S OUT=OUT_"\u"_HEX
 . Q
 Q OUT
 ;
]]></Routine>


<Routine name="FMQLQP" type="MAC" languagemode="0" timestamp="63266,3972.609066"><![CDATA[
FMQLQP ;CG/CD - Caregraf - FMQL Query Processor; 04/03/2020  11:30
 ;;10.0;FMQLQP;;April 3rd, 2020
 ;
 ;
 ; FMQL Query Processor 
 ;
 ; (c) Caregraf 2010-2020
 ;
 ;
 ; Process Query
 ; support RPC or Web serializing friendly ^TMP holding JSON response 
 ; example: QUERY(.REPLY,"DESCRIBE 2-9") will describe the 9th entry in
 ; file 2 into ^TMP($J,"FMQLJSON")
 ; 
QUERY(QUERY) ;
 N PARAMS,PRSRES
 ; Note: storing in TMP for large JSON and older Cache-based systems
 K ^TMP($J,"FMQLJSON")  ; VistA Coding Convention
 ; Need to identify namespace of FM (VISTA or C***)
 K ^TMP($J,"NS") S ^TMP($J,"NS")=$S($P(^DIC(4.3,0),"^")="KERNEL SITE PARAMETERS":"C***",1:"VS")
 S PRSRES=$$PRSQUERY(QUERY,.PARAMS)
 I PRSRES'="" S ^TMP($J,"FMQLJSON",0)="{""error"":""Bad Query Form: "_PRSRES_"""}"
 E  D PROCQRY($NA(^TMP($J,"FMQLJSON")),.PARAMS)
 S REPLY=$NA(^TMP($J,"FMQLJSON"))
 Q REPLY
 ;
FMQLRPC(RPCREPLY,RPCARG) ;
 S RPCREPLY=$$QUERY(RPCARG)
 Q
 ; 
 ;
 ; PRSQUERY
 ; - invoke by S RESULT=$$PRSQUERY(INPUT,.PARAMS)
 ; ... returns a parse error when the INPUT is invalid, otherwise ""
 ;
 ; TODO: 
 ; - fully consume input and error if extraneous items
 ;
PRSQUERY(INPUT,PARAMS) ;
 N ERROR,QRYDEFS,OP,VAL,QUAL,TOKEN,ARGTYPE,NSTRT,NEND,NPOS,INPUTTV,CHECK
 S ERROR=""
 S QRYDEFS("SELECT","TYPE","LIMIT")="NUM"
 S QRYDEFS("SELECT","TYPE","OFFSET")="NUM"
 S QRYDEFS("SELECT","TYPE","AFTERIEN")="ID"
 S QRYDEFS("SELECT","TYPE","UPTOIEN")="ID"
 S QRYDEFS("SELECT","TYPE","NOIDXMAX")="NUM"
 S QRYDEFS("SELECT","TYPE","IN")="QID"
 S QRYDEFS("SELECT","TYPE","ORDERBY")="FLDID"
 S QRYDEFS("SELECT","TYPE","FIELD")="FLDID"
 S QRYDEFS("COUNT","TYPE","LIMIT")="NUM"
 S QRYDEFS("COUNT","TYPE","OFFSET")="NUM"
 S QRYDEFS("COUNT","TYPE","AFTERIEN")="ID"
 S QRYDEFS("COUNT","TYPE","NOIDXMAX")="NUM"
 S QRYDEFS("COUNT","TYPE","IN")="QID"
 S QRYDEFS("COUNT REFS","QID")=""
 S QRYDEFS("DESCRIBE","QID","CSTOP")="NUM"
 S QRYDEFS("DESCRIBE","TYPE","LIMIT")="NUM"
 S QRYDEFS("DESCRIBE","TYPE","OFFSET")="NUM"
 S QRYDEFS("DESCRIBE","TYPE","AFTERIEN")="ID"
 S QRYDEFS("DESCRIBE","TYPE","UPTOIEN")="ID"
 S QRYDEFS("DESCRIBE","TYPE","CSTOP")="NUM"
 S QRYDEFS("DESCRIBE","TYPE","NOIDXMAX")="NUM"
 S QRYDEFS("DESCRIBE","TYPE","IN")="QID"
 S QRYDEFS("DESCRIBE","TYPE","ORDERBY")="FLDID"
 S QRYDEFS("DESCRIBE LAST","TYPE","CSTOP")="NUM"
 S QRYDEFS("SELECT TYPES","NONE","TOPONLY")=""
 S QRYDEFS("SELECT TYPES","NONE","POPONLY")=""
 S QRYDEFS("SELECT TYPE REFS","TYPE")=""
 S QRYDEFS("DESCRIBE BADTYPES","NONE")=""
 S QRYDEFS("DESCRIBE TYPE","TYPE","FULL")=""
 S QRYDEFS("ABOUT","NONE")=""
 ; OP must be at start and can have spaces so loop to find
 D SKPWHITE(.INPUT)
 ; Go through all OPs each time - longest at end of list
 S OP="" F  S OP=$O(QRYDEFS(OP)) Q:OP=""  D
 . S VAL=$E(INPUT,1,$L(OP))
 . ; Either space is next or OP takes up whole input
 . Q:'($L(OP)=$L(INPUT)!($A(INPUT,$L(OP)+1)=32))
 . I VAL=OP S PARAMS("FOP")=OP S PARAMS("OP")=$$EXTTOINT(OP) Q
 I '$D(PARAMS("OP")) S ERROR="OP MISSING"
 Q:ERROR'="" ERROR
 S OP=PARAMS("FOP")
 D EATINP(.INPUT,OP)
 S QUAL="NONE"
 I '$D(QRYDEFS(OP,"NONE")) D
 . S VAL=$$PRSINP(.INPUT)
 . ; QID form ends in E to allow for non numeric 'meaningful' IENs
 . I $D(QRYDEFS(OP,"QID")),VAL?0.N0.1"_"1.N1"-"1.E S PARAMS("TYPE")=$P(VAL,"-",1) S QUAL="QID" S PARAMS("ID")=$P(VAL,"-",2) Q
 . I $D(QRYDEFS(OP,"TYPE")),VAL?0.N0.1"_"1.N S QUAL="TYPE" S PARAMS("TYPE")=VAL Q
 . S ERROR="TYPE MISSING"
 Q:ERROR'="" ERROR
 ; Take out FILTER text before looking at other arguments. It may contain those arguments as keywords. NOIDXMAX is a proxy for FILTER support.
 I $D(QRYDEFS(OP,QUAL,"NOIDXMAX")) D
 . S NSTRT=$F(INPUT,"FILTER")
 . Q:NSTRT=0  ; No Filter
 . S NEND=$F(INPUT,")",NSTRT)
 . S NPOS=NSTRT,NEND=0 F  S NPOS=$F(INPUT,")",NPOS) Q:'NPOS  S NEND=NPOS
 . I NEND=0 S ERROR="FILTER ) MISSING" Q
 . S VAL=$E(INPUT,NSTRT,NEND-1)
 . D SKPWHITE(.VAL)
 . I $E(VAL,1)'="(" S ERROR="FILTER ( MISSING" Q
 . S PARAMS("FILTER")=$E(VAL,2,$L(VAL)-1) ; less brackets
 . ; Redo INPUT to remove FILTER entirely
 . S INPUT=$E(INPUT,1,NSTRT-$L("FILTER")-1)_$E(INPUT,NEND,$L(INPUT))
 Q:ERROR'="" ERROR
 S TOKEN="" F  S TOKEN=$O(QRYDEFS(OP,QUAL,TOKEN)) Q:TOKEN=""!(ERROR'="")  D
 . S NSTRT=$F(INPUT,TOKEN)
 . Q:NSTRT=0  ; TOKEN not found
 . ; TOKEN only argument - by convention make value = 1
 . I QRYDEFS(OP,QUAL,TOKEN)="" S PARAMS(TOKEN)=1 Q
 . S INPUTTV=$E(INPUT,NSTRT,$L(INPUT))  ; There is an argument
 . S VAL=$$PRSINP(.INPUTTV," ",0)
 . ; QID allows E IENs; FLDID must be N or .N or N.N; ID 1.E ie/ not just float. May tighten
 . S ARGTYPE=QRYDEFS(OP,QUAL,TOKEN)
 . S CHECK=$S(ARGTYPE="NUM":VAL?1.N,ARGTYPE="QID":VAL?0.N0.1"_"1.N1"-"1.E,ARGTYPE="FLDID":VAL?0.N0.1"."1.N,ARGTYPE="ID":VAL?1.E,1:1)
 . I CHECK=0 S ERROR="INVALID VALUE FOR "_TOKEN_":"_VAL Q
 . S PARAMS($$EXTTOINT(TOKEN))=VAL
 Q:ERROR'="" ERROR
 ; REM: default of NOIDXMX and CSTOP set further inside
 Q ""
 ;
PROCQRY(REPLY,FMQLPARAMS) ;
 I '$D(FMQLPARAMS("OP")) S @REPLY@(0)="{""error"":""No Operation Specified""}" Q
 ; Version
 I FMQLPARAMS("OP")="ABOUT" D ABOUT(REPLY) Q
 ; Schema
 I FMQLPARAMS("OP")="SELECT TYPES" D ALLTYPES^FMQLSCH(REPLY,.FMQLPARAMS) Q
 I FMQLPARAMS("OP")="DESCRIBE BADTYPES" D BADTYPES^FMQLSCH(REPLY,.FMQLPARAMS) Q
 I FMQLPARAMS("OP")="SELECT TYPE REFS" D ALLREFERRERSTOTYPE^FMQLSCH(.REPLY,.FMQLPARAMS) Q
 I FMQLPARAMS("OP")="DESCRIBE TYPE" D DESCRIBETYPE^FMQLSCH(REPLY,.FMQLPARAMS) Q
 ; Data
 I FMQLPARAMS("OP")="COUNT REFS" D CNTREFS^FMQLDATA(REPLY,.FMQLPARAMS) Q
 I ((FMQLPARAMS("OP")="DESCRIBE")&($D(FMQLPARAMS("ID")))) D DESONE^FMQLDATA(REPLY,.FMQLPARAMS) Q
 I FMQLPARAMS("OP")="DESCRIBE LAST" D DESLAST^FMQLDATA(REPLY,.FMQLPARAMS) Q
 I ((FMQLPARAMS("OP")="SELECT")!(FMQLPARAMS("OP")="COUNT")!(FMQLPARAMS("OP")="DESCRIBE")) D ALL^FMQLDATA(REPLY,.FMQLPARAMS) Q
 S @REPLY@(0)="{""error"":""No Such Operation: "_FMQLPARAMS("OP")_"""}"
 Q
 ;
 ;
 ; ABOUT - only version now 
 ;
ABOUT(REPLY)  ;
 N VER S VER=$P($T(+2),";",3)
 S @REPLY@(0)="{""version"":"""_VER_"""}"
 Q
 ;
 ;
 ; TODO: internal code uses slightly different names for some parameters
 ;
EXTTOINT(EXTNAME) ;
 I EXTNAME="NOIDXMAX" Q "NOIDXMX"
 I EXTNAME="CSTOP" Q "CNODESTOP"
 Q EXTNAME
 ;
 ;
 ;
 ;
PRSINP(INPUT,SEP,EAT) ;
 N VAL
 S:'$D(SEP) SEP=" "
 S:'$D(EAT) EAT=1
 D SKPWHITE(.INPUT)
 S VAL=$P(INPUT,SEP,1)
 I EAT D EATINP(.INPUT,VAL)
 Q VAL
 ;
 ;
 ;
 ;
EATINP(INPUT,VAL) ;
 S INPUT=$E(INPUT,$L(VAL)+1,$L(INPUT))
 Q
 ;
 ;
 ;
 ;
SKPWHITE(INPUT) ;
 N IDX,NEXT,DONE
 S IDX=1
 S DONE=0 F  D  Q:DONE
 . S NEXT=$E(INPUT,IDX)
 . I NEXT="" S DONE=1 Q
 . I $A(NEXT)>32 S DONE=1 Q
 . S IDX=IDX+1
 Q:IDX=1
 S INPUT=$E(INPUT,IDX,$L(INPUT))
 Q
 ;
 ; TMP: move to utils (should be done outside). Removes HTTP escape.
 ;
UNESCSP(INPUT) ;
 N NEXT,DONE
 S DONE=0 F  D  Q:DONE
 . S NEXT=$F(INPUT,"%20")
 . I NEXT=0 S DONE=1 Q
 . S INPUT=$E(INPUT,1,NEXT-4)_" "_$E(INPUT,NEXT,$L(INPUT))
 Q
 ;
]]></Routine>


<Routine name="FMQLSCH" type="MAC" languagemode="0" timestamp="63272,6526.681772"><![CDATA[
FMQLSCH ;CG/CD - Caregraf - FMQL Query Processor; 04/03/2020  11:30
 ;;10.0;FMQLSCH;;April 3rd, 2020
 ;
 ; FMQL Schema Query Processor
 ;
 ; Companion of FMQLDATA - this resolves schema queries. Like its
 ; peer, it uses FLINF utilities rather than reading FM's raw dicts.
 ;
 ; (c) Caregraf 2010-2020
 ;
ALLTYPES(REPLY,FMQLPARAMS) ;
 N FILE,FILELABEL,TOPONLY,POPONLY,TCNT,CNT
 S TOPONLY=0,POPONLY=0,TCNT=0,CNT=0
 I $D(FMQLPARAMS("TOPONLY")),FMQLPARAMS("TOPONLY")="1" S TOPONLY=1
 I $D(FMQLPARAMS("POPONLY")),FMQLPARAMS("POPONLY")="1" S POPONLY=1
 D REPLYSTART^FMQLJSON(REPLY)
 S FILE=.109 ; allow .11 on but no .001 -> .1
 D LISTSTART^FMQLJSON(REPLY,"results")
 F  S FILE=$O(^DD(FILE)) Q:FILE'=+FILE  D
 . N FLINF D BLDFLINF^FMQLUTIL(FILE,.FLINF,0)  ; Important: initialize FLINF here
 . ; Will include WP which has ^DD entry but is not a file for FMQL
 . Q:$D(FLINF("BAD"))
 . S CNT=CNT+1
 . S:'$D(FLINF("PARENT")) TCNT=TCNT+1
 . I TOPONLY=1,$D(FLINF("PARENT")) Q
 . I POPONLY=1,'$D(FLINF("FMSIZE")) Q
 . D DICTSTART^FMQLJSON(REPLY)
 . D DASSERT^FMQLJSON(REPLY,"number",FILE)
 . D DASSERT^FMQLJSON(REPLY,"name",FLINF("LABEL"))
 . D:$D(FLINF("PARENT")) DASSERT^FMQLJSON(REPLY,"parent",FLINF("PARENT"))
 . D:$D(FLINF("GL")) DASSERT^FMQLJSON(REPLY,"global",FLINF("GL"))
 . D:$D(FLINF("FMSIZE")) DASSERT^FMQLJSON(REPLY,"count",FLINF("FMSIZE"))
 . D DICTEND^FMQLJSON(REPLY)
 . Q
 D LISTEND^FMQLJSON(REPLY)
 D DASSERT^FMQLJSON(REPLY,"allCount",CNT)
 D DASSERT^FMQLJSON(REPLY,"topCount",TCNT)
 ; Temporary (will move to a DESCRIBE SYSTEM. SITE and SITE LABEL
 D:$D(^DD("SITE")) DASSERT^FMQLJSON(REPLY,"siteLabel",^DD("SITE"))
 D:$D(^DD("SITE",1)) DASSERT^FMQLJSON(REPLY,"siteId",^DD("SITE",1))
 D DICTSTART^FMQLJSON(REPLY,"fmql")
 D DASSERT^FMQLJSON(REPLY,"OP","SELECT TYPES")
 I TOPONLY=1 D DASSERT^FMQLJSON(REPLY,"TOPONLY","true")
 I POPONLY=1 D DASSERT^FMQLJSON(REPLY,"POPONLY","true")
 D DICTEND^FMQLJSON(REPLY)
 D REPLYEND^FMQLJSON(REPLY)
 Q
 ;
BADTYPES(REPLY,FMQLPARAMS) ;
 N FILE,CNT,HASBFLD,FIELD
 S CNT=0
 D REPLYSTART^FMQLJSON(REPLY)
 S FILE=.109 ; allow .11 on but no .001 -> .1
 D LISTSTART^FMQLJSON(REPLY,"results")
 F  S FILE=$O(^DD(FILE)) Q:FILE'=+FILE  D
 . N FLINF D BLDFLINF^FMQLUTIL(FILE,.FLINF,0)  ; doing field explicitly below if need be (no pred calc)
 . ; WP is a file (has DD entry) but not considered a file for FMQL
 . I $D(FLINF("BAD")),FLINF("BAD")="WP FILE" Q
 . I $D(FLINF("BAD")) D
 . . S CNT=CNT+1
 . . D DICTSTART^FMQLJSON(REPLY)
 . . D DASSERT^FMQLJSON(REPLY,"number",FILE)
 . . D DASSERT^FMQLJSON(REPLY,"corruption",FLINF("BAD"))
 . . D DICTEND^FMQLJSON(REPLY)
 . E  D
 . . S HASBFLD=0,FIELD=0 F  S FIELD=$O(^DD(FILE,FIELD)) Q:FIELD'=+FIELD  D
 . . . N FDINF D BLDFDINF^FMQLUTIL(.FLINF,FIELD,.FDINF)
 . . . I '$D(FDINF("BAD")) Q
 . . . I HASBFLD=0 D
 . . . . S HASBFLD=1
 . . . . S CNT=CNT+1
 . . . . D DICTSTART^FMQLJSON(REPLY)
 . . . . D DASSERT^FMQLJSON(REPLY,"number",FILE)
 . . . . D LISTSTART^FMQLJSON(REPLY,"badfields")
 . . . D DICTSTART^FMQLJSON(REPLY)
 . . . D DASSERT^FMQLJSON(REPLY,"number",FDINF("FIELD"))
 . . . D DASSERT^FMQLJSON(REPLY,"corruption",FDINF("BAD"))
 . . . D DICTEND^FMQLJSON(REPLY)
 . . I HASBFLD=1 D
 . . . D LISTEND^FMQLJSON(REPLY)
 . . . D DICTEND^FMQLJSON(REPLY)
 D LISTEND^FMQLJSON(REPLY)
 D DASSERT^FMQLJSON(REPLY,"badCount",CNT)
 D DICTSTART^FMQLJSON(REPLY,"fmql")
 D DASSERT^FMQLJSON(REPLY,"OP","DESCRIBE BADTYPES")
 D DICTEND^FMQLJSON(REPLY)
 D REPLYEND^FMQLJSON(REPLY)
 Q
 ;
ALLREFERRERSTOTYPE(REPLY,FMQLPARAMS) ;
 N FILE,FILELABEL,RFILE,RFILELABEL,RFIELD,RFIELDLABEL
 I '$D(FMQLPARAMS("TYPE")) D ERRORREPLY(REPLY,"No File Type") Q
 S FILE=$TR(FMQLPARAMS("TYPE"),"_",".")
 I '$D(^DIC(FILE,0,"GL")) D ERRORREPLY(REPLY,"Invalid Global File Type: "_FILE) Q  ; top level only
 D REPLYSTART^FMQLJSON(REPLY)
 S FILELABEL=$O(^DD(FILE,0,"NM",""))
 D DASSERT^FMQLJSON(REPLY,"fmqlFileName",FILELABEL) ; always file name back
 D LISTSTART^FMQLJSON(REPLY,"results")
 S RFILE="" F  S RFILE=$O(^DD(FILE,0,"PT",RFILE)) Q:RFILE'=+RFILE  D  ; Order ala IEN Order
 . Q:'$D(^DIC(RFILE,0,"GL"))  ; TBD: only do globals for now
 . Q:'$D(^DD(RFILE,0,"NM"))  ; rfile must be named
 . D DICTSTART^FMQLJSON(REPLY)
 . S RFILELABEL=$O(^DD(RFILE,0,"NM",""))
 . D DASSERT^FMQLJSON(REPLY,"rfile",RFILE)
 . D DASSERT^FMQLJSON(REPLY,"rfileLabel",RFILELABEL)
 . D LISTSTART^FMQLJSON(REPLY,"rfields")
 . S RFIELD="" F  S RFIELD=$O(^DD(FILE,0,"PT",RFILE,RFIELD)) Q:RFIELD'=+RFIELD  D
 . . Q:'$D(^DD(RFILE,RFIELD,0))  ; Skip Corruption
 . . D DICTSTART^FMQLJSON(REPLY)
 . . S RFIELDLABEL=$P(^DD(RFILE,RFIELD,0),"^") ; TBD quit if no label
 . . D DASSERT^FMQLJSON(REPLY,"rfield",RFIELD)
 . . D DASSERT^FMQLJSON(REPLY,"rfieldLabel",RFIELDLABEL)
 . . D DICTEND^FMQLJSON(REPLY)
 . . Q
 . D LISTEND^FMQLJSON(REPLY)
 . D DICTEND^FMQLJSON(REPLY)
 . Q
 D LISTEND^FMQLJSON(REPLY)
 D DICTSTART^FMQLJSON(REPLY,"fmql")
 D DASSERT^FMQLJSON(REPLY,"OP","SELECT TYPE REFS")
 D DASSERT^FMQLJSON(REPLY,"TYPE",$TR(FILE,".","_"))
 D DASSERT^FMQLJSON(REPLY,"TYPELABEL",FILELABEL)
 D DICTEND^FMQLJSON(REPLY)
 D REPLYEND^FMQLJSON(REPLY)
 Q
 ;
ERRORREPLY(REPLY,MSG) ;
 D REPLYSTART^FMQLJSON(REPLY)
 D DASSERT^FMQLJSON(REPLY,"error",MSG)
 D REPLYEND^FMQLJSON(REPLY)
 Q
 ;
DESCRIBETYPE(REPLY,FMQLPARAMS) ;
 I '$D(FMQLPARAMS("TYPE")) D ERRORREPLY(REPLY,"No File Type") Q
 N FILE S FILE=$TR(FMQLPARAMS("TYPE"),"_",".")
 N FLINF D BLDFLINF^FMQLUTIL(FILE,.FLINF,1)
 ; Note: corrupt file leads to an error with src of corruption
 I $D(FLINF("BAD")) D ERRORREPLY(REPLY,"Corrupt or Invalid File Type: "_FLINF("BAD")) Q
 I $D(FLINF("PARENT")) D SUBFILEINFO(REPLY,.FLINF) Q
 D TOPFILEINFO(REPLY,.FLINF)
 Q
 ;
TOPFILEINFO(REPLY,FLINF) ;
 D REPLYSTART^FMQLJSON(REPLY)
 D DASSERT^FMQLJSON(REPLY,"name",FLINF("LABEL"))
 D DASSERT^FMQLJSON(REPLY,"number",FLINF("FILE"))
 D DASSERT^FMQLJSON(REPLY,"location",FLINF("GL"))
 D:$D(FLINF("FMSIZE")) DASSERT^FMQLJSON(REPLY,"count",FLINF("FMSIZE"))
 D:$D(FLINF("LSTIEN")) DASSERT^FMQLJSON(REPLY,"lastIEN",FLINF("LSTIEN"))
 ; Leaving Descr outside FLINF as used so often.
 I $D(^DIC(FILE,"%D",0))  D  ; DESCRIPTION
 . D WPASTART^FMQLJSON(REPLY,"description")
 . S I=0 F  S I=$O(^DIC(FILE,"%D",I)) Q:I'=+I  D
 . . D WPALINE^FMQLJSON(REPLY,^DIC(FILE,"%D",I,0))
 . . Q
 . D WPAEND^FMQLJSON(REPLY)
 . Q
 D:$D(FLINF("APPGRPS")) DASSERT^FMQLJSON(REPLY,"applicationGroups",FLINF("APPGRPS"))
 D:$D(FLINF("VERSION")) DASSERT^FMQLJSON(REPLY,"version",FLINF("VERSION"))
 D:$D(FLINF("VPACKAGE")) DASSERT^FMQLJSON(REPLY,"vpackage",FLINF("VPACKAGE"))
 D FIELDSINFO(.FLINF)
 D DICTSTART^FMQLJSON(REPLY,"fmql")
 D DASSERT^FMQLJSON(REPLY,"OP","DESCRIBE TYPE")
 D DASSERT^FMQLJSON(REPLY,"TYPE",FLINF("EFILE"))
 D DASSERT^FMQLJSON(REPLY,"TYPELABEL",FLINF("LABEL"))
 D DICTEND^FMQLJSON(REPLY)
 D REPLYEND^FMQLJSON(REPLY)
 Q
 ;
SUBFILEINFO(REPLY,FLINF) ;
 D REPLYSTART^FMQLJSON(REPLY)
 D DASSERT^FMQLJSON(REPLY,"name",FLINF("LABEL"))
 D DASSERT^FMQLJSON(REPLY,"number",FLINF("FILE"))
 D DASSERT^FMQLJSON(REPLY,"parent",FLINF("PARENT"))
 ; TBD: Search CFILE for field that contains this one. Get field and description.
 D FIELDSINFO(.FLINF)
 D DICTSTART^FMQLJSON(REPLY,"fmql")
 D DASSERT^FMQLJSON(REPLY,"OP","DESCRIBE TYPE")
 D DASSERT^FMQLJSON(REPLY,"TYPE",FLINF("EFILE"))
 D DASSERT^FMQLJSON(REPLY,"TYPELABEL",FLINF("LABEL"))
 D DICTEND^FMQLJSON(REPLY)
 D REPLYEND^FMQLJSON(REPLY)
 Q
 ;
FIELDSINFO(FLINF) ;
 N FILE S FILE=FLINF("FILE")
 D LISTSTART^FMQLJSON(REPLY,"fields")
 N FIELD S FIELD=0 F  S FIELD=$O(FLINF("FDINFS",FIELD)) Q:FIELD=""  D
 . N FDINF M FDINF=FLINF("FDINFS",FIELD)
 . Q:$D(FDINF("BAD"))
 . D DICTSTART^FMQLJSON(REPLY)
 . D DASSERT^FMQLJSON(REPLY,"number",FDINF("FIELD"))
 . ; Send over all the flags. May process more on client side
 . D DASSERT^FMQLJSON(REPLY,"flags",FDINF("FLAGS"))
 . D DASSERT^FMQLJSON(REPLY,"name",FDINF("LABEL"))
 . D DASSERT^FMQLJSON(REPLY,"pred",FDINF("PRED"))
 . D:$D(FDINF("LOC")) DASSERT^FMQLJSON(REPLY,"location",FDINF("LOC"))
 . ; For now, only note simple indexes. Not all ^DD(FILE,"IX",FIELD) as MUMPS there too
 . D:$D(FDINF("IDX")) DASSERT^FMQLJSON(REPLY,"index",FDINF("IDX"))
 . D:$D(FDINF("TRIGS")) DASSERT^FMQLJSON(REPLY,"triggers",FDINF("TRIGS"))
 . D:$D(FDINF("CREFNO")) DASSERT^FMQLJSON(REPLY,"crossReferenceCount",FDINF("CREFNO"))
 . D DASSERT^FMQLJSON(REPLY,"type",FDINF("TYPE"))
 . ; Extra details not in FDINF (yet)
 . N FLDDETAILS
 . I FDINF("TYPE")=9 S FLDDETAILS=+FDINF("FLAGS") ; Multiple
 . ; For now, pass back original values even for boolean
 . I ((FDINF("TYPE")=3)!(FDINF("TYPE")=12)) S FLDDETAILS=$P(^DD(FILE,FIELD,0),"^",3) ; Set
 . I FDINF("TYPE")=7 S FLDDETAILS=+$P(FDINF("FLAGS"),"P",2) ; Pointer
 . I FDINF("TYPE")=11,FDINF("FLAGS")["P" S FLDDETAILS=+$P(FDINF("FLAGS"),"P",2) ; Pointer (IEN pts)
 . ; TBD: Final FMQL won't distinguish vptr from ptr. MUMPS-side thing.
 . I FDINF("TYPE")=8 D
 . . S FLDDETAILS=$$VARPOINTERRANGE(FILE,FIELD) ; V Pointer
 . D:$D(FLDDETAILS) DASSERT^FMQLJSON(REPLY,"details",FLDDETAILS)
 . ; TODO: move into FDINF as useful for filters
 . I $L($P(^DD(FILE,FIELD,0),"^",5)) D
 . . ; TODO: calculate better - using length to get over all internal ^
 . . N CALC S CALC=$P(^DD(FILE,FIELD,0),"^",5,$L(^DD(FILE,FIELD,0)))
 . . Q:CALC="Q"
 . . N CALCTYPE S CALCTYPE=$S(FDINF("TYPE")=6:"computation",1:"inputTransform")
 . . D DASSERT^FMQLJSON(REPLY,CALCTYPE,CALC)
 . D:$D(FDINF("HIDE")) DASSERT^FMQLJSON(REPLY,"hidden","true")
 . ; Keeping WP here. Not useful for checking and could be big.
 . I $D(^DD(FILE,FIELD,21,1))  D
 . . D WPASTART^FMQLJSON(REPLY,"description")
 . . N I S I=0 F  S I=$O(^DD(FILE,FIELD,21,I)) Q:I'=+I  D
 . . . D WPALINE^FMQLJSON(REPLY,^DD(FILE,FIELD,21,I,0))
 . . . Q
 . . D WPAEND^FMQLJSON(REPLY)
 . D DICTEND^FMQLJSON(REPLY)
 D LISTEND^FMQLJSON(REPLY)
 Q
 ;
 ; TODO: use FMQLUTIL's instead (PLOC reassemble)
VARPOINTERRANGE(FILE,FIELD) ;
 N X,VPS,VP
 S VPS=""
 I '$D(^DD(FILE,FIELD,"V")) Q VPS ; TBD ERROR
 S X=0 F  S X=$O(^DD(FILE,FIELD,"V",X)) Q:X'=+X  D
 . S VP=$P(^DD(FILE,FIELD,"V",X,0),"^",1)
 . I VPS'="" S VPS=VPS_";"
 . S VPS=VPS_VP
 Q VPS
 ;
]]></Routine>


<Routine name="FMQLSLAB" type="MAC" languagemode="0" timestamp="63152,35930.627635"><![CDATA[
FMQLSLAB ;CG/CD - Caregraf - FMQL Query Processor; 04/03/2020  11:30
 ;;10.0;FMQLSLAB;;April 3rd, 2020
 ;
 ;
 ; FMQL Schema Enhancements for Lab (SLAB)
 ;
 ; (c) Caregraf 2010-2020
 ; 
 ; Exposes hidden Lab (CH) variables to a blank node pending a set of 
 ; cross references that does this work in an enhanced lab schema. This makes
 ; CH labs look like Radiology and Pharmacy.
 ;
 ; This does similar calculations to (lot's of redundancy in lab):
 ; - HL7 lab: subroutines called from CH^LA7OBX1 from GCPR^LA7QRY
 ; - Lab query routines: TSTRES^LRRPU called from CH^LR7OR2
 ; - Other: CHNODE^LRPXAPI2.m
 ; 
 ; CH data is stored in a proprietary format in FileMan's location for a lab
 ; value. Example ...
 ;   "7.19^^81323.0000!!!4378!!!1^6877^70!4.8!10.8!2!50!!x10 3/uL!1!3^^^^1"
 ; The structure of such values is explained in the code below.
 ;
 ; Note: unlike the VA routines, the code below DOES NOT account for older versions
 ; of the lab package which failed to fill in certain values.
 ;
 ; Issue of inconsistent settings in 60:
 ; VistA seems to allow meaningless definitions in file 60 ...
 ; - numerics with no units? (ex/ GWB, 60-1100, 60-5173)
 ; - references for free texts (ex/ GWB, 60-6135, 60-5826)
 ; - set values with a mix of numeric and text and still get ref ranges and units
 ;   (ex/ GWB, 60-151)
 ; - numeric but interpretation is an explanation (60-5865)
 ; - ... TBD: check type in 60 AND ONLY send ranges, units if numeric.
 ; For now, this extractor DOES not remove such inconsistencies. Must choose the 
 ; right balance between a consistent schema and exposing what the system has.
 ;
 ; TBD:
 ; - panel to lab order. Work correlation - logic in LR7OR1. Custom indexes
 ;   in 68 and 69 to go from a "lab order id" to file 100 id. Not like pharma
 ;   - the id is not called out explicitly in a field
 ; - value of "see comment"
 ; - TYPE: SET vs NUMERIC vs STRING from 60
 ;   - LA7VOBX1: $S("canccomment"[$P(LA7VAL,"^"):1,1:0)
 ;   - OBX2^LA7VOBXA: TYPE
 ; - Partial or Final
 ;   S LA7X=$S("canccommentpending"[$P(LA7VAL,"^"):$P(LA7VAL,"^"),1:"F")
 ;   I LA7RS="C" S LA7X=LA7RS
 ;   S LA7OBX(11)=$$OBX11^LA7VOBX(LA7X)
 ; - Problem of "Free Text" 60 with a unit. ie. if non numeric nix unit
 ; - Critical vs Reference: HL7 V3 HH (High Alert) vs H (High)? Or just expose
 ;   critical and leave interpretation to the client?
 ;
 ;
BLDBNODES(FAR6304,FID) N BID,FLOC,ID,VAL
 S ID=$P(FID,"_")
 S BID=1
 D BNLISTSTART^FMQLJSON(REPLY,"9999999999_6304","CHVALS","9999999999")
 S FLOC=1 F  S FLOC=$O(@FAR6304@(ID,FLOC)) Q:FLOC'=+FLOC  D
 . S VAL=@FAR@(ID,FLOC)
 . D BLDBNODE(FLOC,VAL,BID_"_"_FID)
 . S BID=BID+1
 D BNLISTEND^FMQLJSON(REPLY)
 Q
 ;
BLDBNODE(FLOC,VAL,FID) ;
 ; Start with 60 reference. Must have it or quit.
 N LC S LC=$P(VAL,"^",3)  ; Codes
 Q:LC=""
 N LC60 S LC60=$P(LC,"!",7)  ; 60 ref is in 7th position of code section
 Q:LC60=""
 Q:'$D(^LAB(60,LC60))
 N LABEL60 S LABEL60=$P(^LAB(60,LC60,0),"^")
 ;
 N LVAL S LVAL=$P(VAL,"^")  ; Get Value. TBD: need to check if there is one?
 ;
 ; TBD: FILTER (two values to pick)
 ; Check if test is OK to send - (O)utput or (B)oth
 ; S LA7X=$P(VAL,"^",12)
 ; I LA7X]"","BO"'[LA7X Q
 ; I LA7X="",'$$OKTOSND^LA7VHLU1(LRSS,LRSB,+$P($P(LA7VAL,"^",3),"!",7)) Q
 ;
 D DICTSTART^FMQLJSON(REPLY)
 ;
 D DASSERT^FMQLJSON(REPLY,"ien",FID)
 ;
 ; Codes (TBD: don't take 64/LOINC. Take from 60->64->95.3)
 ; Result 64. Default to Order 64 (or ""). Nix NaN WKLD code
 ; S:$P(LC,"!")="81323.0000" $P(LC,"!")=""
 ; S:$P(LC,"!",2)="81323.0000" $P(LC,"!",2)=""
 ; N LC64 S LC64=$S($P(LC,"!",2)'="":$P(LC,"!",2),1:$P(LC,"!"))
 ; 0.1 IEN of 60
 ; N SAMEAS60 ; LOINC (95.3) or NLT (64) if available
 ; I $P(LC,"!",3)'="" S SAMEAS60("URI")="95_3-"_$P(LC,"!",3) S SAMEAS60("LABEL")="DUMMYLOINC"
 ; E  I LC64'="" S SAMEAS60("URI")="64-"_LC64 S SAMEAS60("LABEL")="DUMMY64"
 D PTRAST^FMQLJSON(REPLY,"TEST","60-"_LC60,LABEL60)
 ;
 ; 0.2: Value (complication of "see comment" and type)
 D DASSERT^FMQLJSON(REPLY,"VALUE",LVAL)
 ;
 ; 0.11: Method or Site - TBD redo per OBX17^LA7VOBX
 ; Note: Mayo appears here in MMH as one of three options. Goes to WKLD suffix.
 I $P(LC,"!",4) D
 . Q:'$D(^LAB(64.2,$P(LC,"!",4)))
 . N LABEL S LABEL=$P(^LAB(64.2,$P(LC,"!",4),0),"^")
 . D PTRAST^FMQLJSON(REPLY,"METHOD","64_2-"_$P(LC,"!",4),LABEL)
 ;
 ; 0.4: Verify Person
 I $P(VAL,"^",4) D
 . Q:'$D(^DPT($P(VAL,"^",4)))
 . N LABEL S LABEL=$P(^DPT($P(VAL,"^",4),0),"^")
 . D PTRAST^FMQLJSON(REPLY,"VERIFY PERSON","200-"_$P(VAL,"^",4),LABEL)
 ;
 ; Reference Ranges and Unit (Configured in 60.01 Specimen)
 ; take from value as 60.01 may have changed since interpretation
 ; TBD: consider interpretation as coded value for ease of mapping to obsi/H, obsi/L
 N LRU S LRU=$P(VAL,"^",5)  ; Reference Ranges and Unit
 D:$P(LRU,"!",7)'="" DASSERT^FMQLJSON(REPLY,"UNITS",$P(LRU,"!",7))
 ; .08: Specimen (61). Also in $P(0,"^",5)
 I $P(LRU,"!") D
 . Q:'$D(^LAB(61,$P(LRU,"!")))
 . N LABEL S LABEL=$P(^LAB(61,$P(LRU,"!"),0),"^")
 . D PTRAST^FMQLJSON(REPLY,"SPECIMEN","61-"_$P(LRU,"!"),LABEL)
 ; .09,.10: Range - high and low
 ; Ignore criticals (4/5). Use reference. If none, use therapeutic.
 N LRLOW S LRLOW=$S($P(LRU,"!",2)'="":$P(LRU,"!",2),1:$P(LRU,"!",11))
 D:LRLOW'="" DASSERT^FMQLJSON(REPLY,"RANGE LOW",LRLOW)
 N LRHIGH S LRHIGH=$S($P(LRU,"!",3)'="":$P(LRU,"!",3),1:$P(LRU,"!",12))
 D:LRHIGH'="" DASSERT^FMQLJSON(REPLY,"RANGE HIGH",LRHIGH)
 ;
 ; 0.3: Interpretation (not there for NORMAL or no reference ranges)
 D:$P(VAL,"^",2)'="" DASSERT^FMQLJSON(REPLY,"INTERPRETATION",$P(VAL,"^",2))
 ;
 D DICTEND^FMQLJSON(REPLY)
 ;
 Q
 ;
]]></Routine>


<Routine name="FMQLUTIL" type="MAC" languagemode="0" timestamp="63260,32180.432532"><![CDATA[
FMQLUTIL ;CG/CD - Caregraf - FMQL Utils; 04/03/2020  11:30
 ;;10.0;FMQLUTIL;;April 3rd, 2020
 ;
 ;
 ; FMQL Utilities 
 ;
 ; (c) Caregraf 2010-2020
 ;
 ;
 ; eXecute a routine, TOX (TO eXecute) on members of a file. Flexible - TOX
 ; can do anything from a straightforward exposure of file contents to 
 ; counting to aggregations of various kinds.
 ; - for both globals and cnodes
 ;   - IENA="" if GL - ie/ only set for CNODE
 ; - Controls position in file with LIMIT, OFFSET, AFTERIEN, UPTOIEN
 ; - PARAMS allows extra values to be passed to TOX
 ; - NOIDXMX = Maximum size of file to filter where no index exists. -1 means no max. This
 ;   matters for filters. You don't want to make a linear search of a huge file looking 
 ;   for a couple of entries. Note: not being set in MUMPS - upper bound set in Apache
 ; - Special case: ORDERBY - for now only on .01 if the B Index
 ;
XONFL(FLINF,FILTER,IENA,LIMIT,OFFSET,AFTERIEN,UPTOIEN,ORDERBY,NOIDXMX,TOX,PARAMS) ;
 N PLC,MFLT,IDXA,IDXSTART
 I AFTERIEN'="" S OFFSET=0  ; Ensure OFFSET off if AFTERIEN
 S PLC("LIMIT")=LIMIT,PLC("OFFLFT")=OFFSET,PLC("AFTERIEN")=AFTERIEN,PLC("UPTOIEN")=UPTOIEN,PLC("CNT")=0
 ; Build filter expression
 S MFLT=$S(FILTER'="":"S MFTEST="_$$FLTTOM^FMQLFILT(.FLINF,FILTER,IENA),1:"")
 ; CNodes walk IENA.
 I '$D(FLINF("GL")) D XFAR(.FLINF,IENA,MFLT,.PLC,TOX,.PARAMS) Q PLC("CNT")
 ; Special case: ORDER BY .01 and BIDX supported
 I ORDERBY=".01",$D(FLINF("BIDX")) D XIDXA(.FLINF,FLINF("BIDX"),"",MFLT,.PLC,TOX,.PARAMS) Q PLC("CNT")
 ; Global but no filter - walk IENA
 I MFLT="" D XFAR(.FLINF,FLINF("ARRAY"),"",.PLC,TOX,.PARAMS) Q PLC("CNT")
 ; See if filter yields an IDXA(V)
 D FLTIDX^FMQLFILT(.FLINF,FILTER,.IDXA,.IDXSTART)
 ; 5 Cases:
 ; - a. non > filter gives IDXAV (IDXSTART="")
 I $G(IDXA)'="",$G(IDXSTART)="" D XIDXAV(.FLINF,IDXA,MFLT,.PLC,TOX,.PARAMS) Q PLC("CNT")
 ; - b. > filter gives IDXA (IDXSTART'="")
 I $G(IDXA)'="" D XIDXA(.FLINF,IDXA,IDXSTART,MFLT,.PLC,TOX,.PARAMS) Q PLC("CNT")
 ; - c. manual IDXA (100,52). Use XIDXA non leaf indexes. No MFLT
 D MFLTIDX^FMQLFILT(.FLINF,FILTER,.IDXA,.IDXSTART)
 I $G(IDXA)'="" D XIDXA(.FLINF,IDXA,"","",.PLC,TOX,.PARAMS) Q PLC("CNT")
 ; - d. No IDXA(V) but filter. See if file too big to filter
 I NOIDXMX'=-1,($S($D(FLINF("FMSIZE")):FLINF("FMSIZE")>NOIDXMX,1:1)) Q -1
 ; - e. file not to big to filter, row by row
 D XFAR(.FLINF,FLINF("ARRAY"),MFLT,.PLC,TOX,.PARAMS)
 S:$G(PLC("LIEN")) PARAMS("LIEN")=PLC("LIEN")
 Q PLC("CNT")
 ;
 ;
 ; Apply TOX on entries in a simple IEN Array
 ; 
 ; Used for plain walks of files in IEN order, for contained node walks and 
 ; for non-indexed filtering of smaller files.
 ;
XFAR(FLINF,FAR,MFLT,PLC,TOX,PARAMS) ;
 N AIEN,IEN,MFTEST
 ; Assumption: OFFLFT=0 if AFTERIEN as it takes precedence
 S AIEN=$S($D(PLC("AFTERIEN")):PLC("AFTERIEN"),1:0)
 S PLC("LIEN")=""
 S IEN=AIEN F  S IEN=$O(@FAR@(IEN)) Q:(IEN'=+IEN)!(PLC("CNT")=PLC("LIMIT"))!(PLC("UPTOIEN")&(IEN>=PLC("UPTOIEN")))  D
 . Q:($P($G(@FAR@(IEN,0)),"^")="")  ; All must have .01 value
 . I MFLT'="" X MFLT Q:'MFTEST  ; Quit if filter fails
 . I PLC("OFFLFT")>0 S PLC("OFFLFT")=PLC("OFFLFT")-1 Q  ; Quit if not at offset
 . S PLC("CNT")=PLC("CNT")+1
 . X TOX  ; Takes .FLINF, IEN, FAR (for CNodes), PARAMS (extras)
 . S PLC("LIEN")=IEN
 Q
 ;
 ;
 ; An IDX Value Array (IDXAV) is more involved than a simple IEN array
 ; - IDX's can embed alias' ex/ ^DPT("B",NAME,IEN,"X")=1
 ; - IENs may not be in the leaf/last position
 ; and though we walk the IDXAV, we apply TOX to the global
 ; 
 ; Directly for = filters where the predicate asserted is indexed. Key 
 ; for efficiently traversing the graph arrangements (Vital points to Patient)
 ; 
XIDXAV(FLINF,IDXAV,MFLT,PLC,TOX,PARAMS) ;
 N FAR,AIEN,IEN,MFTEST
 I '$D(FLINF("GL")) Q -1  ; globals only, CNodes walked in XFAR 
 S FAR=FLINF("ARRAY")  ; FAR != IDXAV
 ; Assumption: OFFLFT=0 if AFTERIEN as it takes precedence
 S AIEN=$S($D(PLC("AFTERIEN")):PLC("AFTERIEN"),1:0)
 I '$D(PLC("LIEN")) S PLC("LIEN")=AIEN
 S IEN=AIEN F  S IEN=$O(@IDXAV@(IEN)) Q:IEN'=+IEN!(PLC("CNT")=PLC("LIMIT"))!(IEN=PLC("UPTOIEN"))  D
 . Q:IEN=PLC("LIEN")  ; Traverse above leaves means same IEN > once in order
 . S PLC("LIEN")=IEN  ; Need to track across walks if 2 step IDXA
 . Q:$G(@IDXAV@(IEN))'=""  ; Skip all aliases. Aliases appear out of order
 . Q:($P($G(@FAR@(IEN,0)),"^")="")  ; All must have .01 value
 . I MFLT'="" X MFLT Q:'MFTEST  ; Quit if filter fails
 . I PLC("OFFLFT")>0 S PLC("OFFLFT")=PLC("OFFLFT")-1 Q  ; Quit if not at offset
 . S PLC("CNT")=PLC("CNT")+1
 . X TOX  ; Takes .FLINF, IEN, FAR (for CNodes), PARAMS (extras)
 Q
 ;
 ;
 ; IDX Array traversal is a two stepper: walk the array in value order and
 ; step down into the value arrays.
 ;
 ; Used for > filters and ORDERBY (which is equivalent to > "") 
 ;
XIDXA(FLINF,IDXA,IDXSTART,MFLT,PLC,TOX,PARAMS) ;
 N IDXV,IDXVA
 S IDXV=IDXSTART F  S IDXV=$O(@IDXA@(IDXV)) Q:IDXV=""  D
 . S IDXVA=$NA(@IDXA@(IDXV))
 . D XIDXAV(.FLINF,IDXVA,MFLT,.PLC,TOX,.PARAMS)
 Q
 ;
 ;
 ; File's are globals (T files) or subfiles (S files)
 ;
BLDFLINF(FILE,FLINF,EXTENT) ;
 S FILE=$TR(FILE,"_",".")
 S FLINF("FILE")=FILE
 S FLINF("EFILE")=$TR(FILE,".","_")
 I '$D(^DD(FILE)) S FLINF("BAD")="No such file" Q
 I '$D(^DD(FILE,.01,0)) S FLINF("BAD")=".01 corrupt" Q
 ; Note 1 field for Multiple means list element
 N FIELD,NOFIELDS
 S FIELD=0,NOFIELDS=0 F  S FIELD=$O(^DD(FILE,FIELD)) Q:FIELD'=+FIELD  S NOFIELDS=NOFIELDS+1
 I NOFIELDS=0 S FLINF("BAD")="No fields" Q
 S FLINF("NOFIELDS")=NOFIELDS
 I $D(^DIC(FILE,0,"GL")) D BLDTFINF(FILE,.FLINF,EXTENT) Q
 I $G(^DD(FILE,0,"UP"))'="" D BLDSFINF(FILE,.FLINF,EXTENT) Q
 S FLINF("BAD")="No global or multiple definition"
 Q
 ;
 ;
 ; Top File Info
 ; Fields: ARRAY, BIDX, FILE, FLAGS, FMSIZE, GL, LABEL
 ;
BLDTFINF(FILE,FLINF,EXTENT) ;
 I $G(^DIC(FILE,0))="" S FLINF("BAD")="^DIC 0 Has No Data" Q
 S FLINF("GL")=^DIC(FILE,0,"GL")
 ; Handle ^DPT( and ^GMR(120.5,
 S FLINF("ARRAY")=$E(FLINF("GL"),1,$L(FLINF("GL"))-1)
 I FLINF("ARRAY")["(" S FLINF("ARRAY")=FLINF("ARRAY")_")"
 ; S FLINF("ARRAY")=$TR(FLINF("GL"),",",")")
 I '$D(@FLINF("ARRAY")@(0)) S FLINF("BAD")="No 0 Entry for Array" Q
 S FLHDR=@FLINF("ARRAY")@(0)
 I $P(FLHDR,"^")="" S FLINF("BAD")="No Name" Q
 ; TODO: have just LABEL. Do non native changes above this.
 ; S FLINF("LABEL")=$TR($P(FLHDR,"^"),"/","_")  ; alt is ^DD(FILE,0,"NM")
 S FLINF("LABEL")=$P(FLHDR,"^")
 S FLINF("FLAGS")=$P(FLHDR,"^",2)
 ; don't always have size
 I $P(FLHDR,"^",4) S FLINF("FMSIZE")=+$P(FLHDR,"^",4)
 I $P(FLHDR,"^",3) S FLINF("LSTIEN")=$P(FLHDR,"^",3)
 ; Version information
 S:$D(^DD(FILE,0,"VR")) FLINF("VERSION")=^DD(FILE,0,"VR")
 S:$D(^DD(FILE,0,"VRPK")) FLINF("VPACKAGE")=^DD(FILE,0,"VRPK")
 ; Not sending VRRV as formats vary - ex/ 80 vs 798.1
 I $D(^DIC(FILE,"%",1))  D  ; APP GROUPS
 . S APGSVAL=""
 . S I=0 F  S I=$O(^DIC(FILE,"%",I)) Q:I'=+I  D 
 . . I APGSVAL'="" S APGSVAL=APGSVAL_";"
 . . S APGSVAL=APGSVAL_^DIC(FILE,"%",I,0)
 . . Q
 . S FLINF("APPGRPS")=APGSVAL
 ; I $D(@FLINF("ARRAY")@("B")) S FLINF("BIDX")=FLINF("GL")_"""B"")"
 ; S:$P($G(@FLINF("ARRAY")@(.01,1,1,0)),"^",2)="B" FLINF("BIDX")=FLINF("GL")_"""B"")"
 S:$$FIELDIDX(FILE,".01")="B" FLINF("BIDX")=FLINF("GL")_"""B"")"
 ; # of fields is: $P(^DD(FILE,0),"^",0)
 D:$G(EXTENT)>0 BLDFLHIE(.FLINF,EXTENT)
 Q
 ;
 ;
 ; Sub or contained file Info
 ; Most (all?) sub file's named in files ie. 120_81 inside 120_8 but can't 
 ; key off that.
 ; FIELDS: FILE, LABEL, PARENT, PFIELD, PLOCSUBS
 ;
BLDSFINF(FILE,FLINF,EXTENT) ;
 ; Ex/ ^DD(8925.02,.01,0)="REPORT TEXT^W^^0;1^Q"
 ; Used '$$VFILE^DILFD(FILE) elsewhere to same effect
 ; WP is a file (has DD entry) but not considered a file for FMQL
 I $P($G(^DD(FILE,.01,0)),"^",2)["W" S FLINF("BAD")="WP FILE" Q
 I '$D(^DD(FILE,0,"NM")) S FLINF("BAD")="No Name" Q
 S FLINF("LABEL")=$O(^DD(FILE,0,"NM",""))
 S FLINF("PARENT")=^DD(FILE,0,"UP")
 ; TODO: check slow down but needed to get at Subfile Array anyhow
 N PFLINF D BLDFLINF(FLINF("PARENT"),.PFLINF,0)
 I $D(PFLINF("BAD")) S FLINF("BAD")="Corrupt Parent: "_PFLINF("BAD") Q
 I '$D(^DD(FLINF("PARENT"),"SB",FILE)) S FLINF("BAD")="Parent doesn't know this multiple" Q
 ; Get Field by Sub File id and not by sub file label in "B"
 S FLINF("PFIELD")=$O(^DD(FLINF("PARENT"),"SB",FILE,""))  ; SubFile location in parent
 I '$D(^DD(FLINF("PARENT"),FLINF("PFIELD"),0)) S FLINF("BAD")="Multiple doesn't know parent's field for it" Q
 S PLOCPOS=$P(^DD(FLINF("PARENT"),FLINF("PFIELD"),0),"^",4)
 I PLOCPOS="" S FLINF("BAD")="No location information" Q
 I $P(PLOCPOS,";",2)'="0" S FLINF("BAD")="Multiple not in position 0" Q
 S FLINF("PLOCSUB")=$P(PLOCPOS,";")
 D:$G(EXTENT)>0 BLDFLHIE(.FLINF,EXTENT)
 Q
 ;
 ;
 ; Field Info
 ; Fields: FIELD, FLAGS, LABEL, LOCPOS, LOCSUB, TYPE
 ; Specials fields: CODES (for type 3)
 ; ... does NOT calculate 'pred'. Right now JSON picks pred. Need to
 ; calculate but one off efficiently
 ; 
 ; TODO: 
 ; - redesign: consider more MUMPy FDINF inside FLINF ie/ FDINFS,FIELD,xx
 ; - Careful: gfs_frm.htm not definite. Ex/ "S" in flags if multiple with only
 ; one field, a set of codes (ex/ 120.506S for ^DD(120.5,4,0)
 ; - Computed (C) is DC,BC,C,Cm,Cmp. Must distinguish actual type. Correlate with no location
 ; - move IDX in here from Sch serializer: want for filters
 ; - Add ^DD(FILE,FIELD,1,1,...)
 ; - consider FDINF extended that will include PRED (costly) and Inputtransform etc
 ;   ... right now done inline
 ;
BLDFDINF(FLINF,FIELD,FDINF) ;
 N MFLAG
 N FILE S FILE=FLINF("FILE")
 S FIELD=$TR(FIELD,"_",".")
 S FDINF("FIELD")=FIELD
 I '$D(^DD(FILE,FIELD,0)) S FDINF("BAD")="No 0 Definition: "_FILE_"/"_FIELD Q
 N FLAGS S FLAGS=$P(^DD(FILE,FIELD,0),"^",2)
 S FDINF("FLAGS")=FLAGS
 S FDINF("LABEL")=$P(^DD(FILE,FIELD,0),"^")
 ; Date/Number/Codes/String/WP String/Pointer/V Pointer/MULT/MUMPS
 I +FLAGS D  ; WP and MULT flag start with the subfile number
 . ; WP special - need to reach into its 'file' to see what it is
 . I $P($G(^DD(+FLAGS,.01,0)),"^",2)["W" S FDINF("TYPE")=5
 . E  S FDINF("TYPE")=9 S FDINF("SUBFILE")=+FLAGS  ; 'M' does not mean Multiple
 E  D
 . ; Standard FileMan uses K for MUMPS; C*** uses Q
 . S MFLAG=$S(^TMP($J,"NS")="C***":"Q",1:"Q")
 . ; .001 in FM is IEN - may be more than a # ie/ a date or a pointer
 . ; If computed (C), punt to client - BC, DC, Cmp - until FMQL calcs computeds
 . ; Note: Cm does not mean Computed Multiple. 'm' means multi-line string
 . S FDINF("TYPE")=$S(FIELD=.001:11,FLAGS["C":6,FLAGS["D":1,FLAGS["N":2,FLAGS["S":3,FLAGS["F":4,FLAGS["P":7,FLAGS["V":8,FLAGS[MFLAG:10,1:"4") ; Default to String
 . ; IDX setting now in BLDCREFS - keeping older routine as may move back for speed. Now recalculating cross refs in every pass
 . ; N IDX S IDX=$$FIELDIDX^FMQLUTIL(FILE,FIELD)
 . ; S:IDX'="" FDINF("IDX")=IDX
 . D BLDCREFS(FILE,FIELD,.FDINF)
 ; TODO: this BAD is never reached as type defaults to String
 I FDINF("TYPE")="" S FDINF("BAD")="No type set: "_FILE_"/"_FIELD Q
 ; In VistA, Access, Verify in file 200 are not always encrypted (C*** encrypts its equivalents). Explicitly mark as sensitive.
 I FILE=200,((FIELD=2)!(FIELD=11)) S FDINF("HIDE")="SENSITIVE"
 I '((FDINF("TYPE")=6)!(FDINF("TYPE")=11)) D
 . S FDLOC=$P(^DD(FILE,FIELD,0),"^",4)
 . S FDINF("LOC")=FDLOC
 . S FDINF("LOCSUB")=$P(FDLOC,";")
 . ; Check for " ; "? ie. spaces even though field not given as computed
 . I $TR(FDINF("LOCSUB")," ")="" S FDINF("BAD")="Corrupt location: "_FILE_"/"_FIELD Q
 . ; Position of 9 is 1 but that's meaningless. Leave out position.
 . I FDINF("TYPE")'=9 D
 . . N LOCWHERE S LOCWHERE=$P(FDLOC,";",2)
 . . I LOCWHERE="" S FDINF("BAD")="No location position: "_FILE_"/"_FIELD Q
 . . ; Extract form for 63/.1 (E1,19) or 68/.1;E1,220 (limit for screenman?)
 . . I LOCWHERE?1"E"1.N1","1.N S FDINF("LOCE")=$E(LOCWHERE,1,$L(LOCWHERE)) Q
 . . I LOCWHERE=+LOCWHERE S FDINF("LOCPOS")=LOCWHERE Q
 . . ; TBD: is there another position type? Return an error until I support it.
 . . S FDINF("BAD")="Unsupported location position: "_FILE_"/"_FIELD_":"_LOCWHERE Q
 I FDINF("TYPE")=3 D 
 . ; Exposes codes as either Enums or Booleans
 . N CODES,UCODES,C,MN,CLABEL
 . S CODES=$P(^DD(FILE,FIELD,0),"^",3)
 . S UCODES=$TR(CODES,"yesno","YESNO") ; Yes to YES, No to NO
 . ; Boolean if 2 values Y:YES;N:NO etc.
 . I $L(UCODES,";")=3,((UCODES["Y:YES;"&(UCODES["N:NO;"))!(UCODES["Y:Y;"&(UCODES["N:N;"))!(UCODES["1:YES;"&(UCODES["0:NO;"))!(UCODES["1:Y;"&(UCODES["0:N;"))) S FDINF("TYPE")=12
 . ; or Boolean if 1 value Y:YES etc or name of field is name of value
 . ; label check is simple: won't catch "X Flag"/"1:X" etc.
 . E  I $L(UCODES,";")=2,((UCODES="1:"_FDINF("LABEL")_";")!(UCODES="Y:YES;")!(UCODES="N:NO;")!(UCODES="Y:Y;")!(UCODES="N:N;")!(UCODES="1:YES;")!(UCODES="0:NO;")!(UCODES="1:Y;")!(UCODES="0:N;")) S FDINF("TYPE")=12
 . F C=1:1 Q:$P(CODES,";",C)=""  D
 . . S MN=$P($P(CODES,";",C),":")
 . . S CLABEL=$P($P(CODES,";",C),":",2)
 . . I FDINF("TYPE")=12 S FDINF("CODES",MN)=$S(MN["1":"true",MN["Y":"true",MN["y":"true",FDINF("LABEL")=CLABEL:"true",1:"false") Q
 . . S FDINF("CODES",MN)=CLABEL
 . . Q
 . Q
 I FDINF("TYPE")=7 S FDINF("PFILE")=+$P(FLAGS,"P",2) S FDINF("PEFILE")=$TR(FDINF("PFILE"),".","_") Q
 ; .001 can be a P(ointer), D(ate), F(string), N(numeric) - assuming can't be VPTR
 I FDINF("TYPE")=11,FLAGS["P" S FDINF("PFILE")=+$P(FLAGS,"P",2) S FDINF("PEFILE")=$TR(FDINF("PFILE"),".","_") Q
 I FDINF("TYPE")=9 S FDINF("BFILE")=+FLAGS Q
 I FDINF("TYPE")=8 D
 . I '$D(^DD(FILE,FIELD,"V")) S FDINF("BAD")="No VPTR Definition: "_FILE_"/"_FIELD Q
 . S X=0 F  S X=$O(^DD(FILE,FIELD,"V",X)) Q:X'=+X  D
 . . N PFILE S PFILE=$P(^DD(FILE,FIELD,"V",X,0),"^",1)
 . . I '$D(^DIC(PFILE,0,"GL")) S FDINF("BAD")="No Global for VPTR target: "_PFILE Q
 . . N PLOC S PLOC=^DIC(PFILE,0,"GL")
 . . S FDINF("PLOC",PLOC)=PFILE
 . . S FDINF("PLOCE",PLOC)=$TR(PFILE,".","_")
 . . S FDINF("PFILE",PFILE)=PLOC
 Q
 ;
 ;
 ; Prepopulate all FDINFs of an FLINF - will also:
 ; - populate unique (in context of file) preds. 
 ; - account for reserved pred (type, _id etc) and that JSON preds can't lead with \d
 ; ... key change in form and scope of field names
 ;
 ; This gives little for a "describe one" but for a cacher with a "describe many", it avoids
 ; building and rebuilding the FLINF and its components for every record being read.
 ; 
 ; Option in BLDFLINF to avoid rebuilding FDINFs and recalculating predicate uniqueness with every file dd loop
 ; but not mandatory as sometimes you just want FLINF
 ; 
 ; Extent=1 => just top fields, =2 => go down to Contained Types
 ; 
BLDFLHIE(FLINF,EXTENT)
 Q:EXTENT=0
 N SEEN S SEEN("type")="",SEEN("id")="",SEEN("_id")="",SEEN("label")="",SEEN("ien")="",SEEN("parent")="" 
 N FIELD S FIELD=0 F  S FIELD=$O(^DD(FLINF("FILE"),FIELD)) Q:FIELD'=+FIELD  D
 . N FDINF D BLDFDINF^FMQLUTIL(.FLINF,FIELD,.FDINF)
 . Q:$D(FDINF("BAD"))
 . N PRED S PRED=$$FIELDTOPRED(FDINF("LABEL")) 
 . S:$E(PRED)?1N PRED="_"_PRED  ; JSON not start with number (www.w3.org/TR/1999/REC-xml-names-19990114/#NT-NCName)
 . S:$D(SEEN(PRED)) PRED=PRED_"_"_$TR(FDINF("FIELD"),".","_")
 . S FDINF("PRED")=PRED
 . S SEEN(PRED)=""
 . ; Multiple embedding
 . I (FDINF("TYPE")=9)&(EXTENT=2) D
 . . N BFLINF D BLDFLINF^FMQLUTIL(FDINF("BFILE"),.BFLINF,2)
 . . S BFLINF("HPRED")=$S($D(FLINF("HPRED")):FLINF("HPRED")_"/"_FDINF("PRED"),1:FDINF("PRED"))
 . . M FDINF("BFLINF")=BFLINF
 . M FLINF("FDINFS",FIELD)=FDINF
 Q
 ;
 ;
 ; Get first non-mumps index for a field.
 ; TBD: check ^DD(FILE,"IX",FIELD) - compare to walk below
 ; TBD: support .11 ie. Walk its ^DD("IX","B",FILE#) or ? ie. XREFs defined outside file. Equivalent of DESRIBE _11 FILTER(.01=[FILE]&&.2=R) and look at fields. Will need to distinguish .11 INDEX from Simple like B. Use array.
 ; 
 ; TODO: relying on CREF util below to fill in FDINF. Keeping in case move back for speed reasons
 ;
FIELDIDX(FILE,FIELD) ;
 N IDXID,IDXINF,IDX
 I FILE=8927.1,FIELD=.01 Q "B" ; Missing from TIU TEMPLATE FIELD ^DD
 S IDX=""
 ; From '$D(^DD(FILE,FIELD,1))
 I '$D(^DD(FILE,FIELD,1,1)) Q ""  ; indexes number 1 up
 S IDXID=0 F  S IDXID=$O(^DD(FILE,FIELD,1,IDXID)) Q:((IDXID'=+IDXID)!(IDX'=""))  D  ; > 0 has indexes
 . Q:'$D(^DD(FILE,FIELD,1,IDXID,0))  ; TBD Corruption note
 . S IDXINF=^DD(FILE,FIELD,1,IDXID,0)
 . I $P(IDXINF,"^",3)'="MUMPS" S IDX=$P(^DD(FILE,FIELD,1,IDXID,0),"^",2) Q
 Q IDX
 ;
 ; 
 ; Fill in FLD CROSS REF INFO
 ;
 ; Get IDX, TRIGGERs and total number of CREFS of a field. Peer of MUMPS Cross References.
 ; 
 ; TODO: move 100, 52 MUMPS special IDX in here
 ;
BLDCREFS(FILE,FIELD,FDINF) ;
 N IDXID,IDXINF,IDXTYP,TRIGFILE,TRIGFLD,TRIGPRED
 I FILE=8927.1,FIELD=.01 S FDINF("IDX")="B" ; Missing from TIU TEMP FLD ^DD
 I '$D(^DD(FILE,FIELD,1,1)) Q
 S IDXID=0 F  S IDXID=$O(^DD(FILE,FIELD,1,IDXID)) Q:IDXID'=+IDXID  D
 . Q:'$D(^DD(FILE,FIELD,1,IDXID,0))
 . S FDINF("CREFNO")=$S($D(FDINF("CREFNO")):FDINF("CREFNO")+1,1:1)
 . S IDXINF=^DD(FILE,FIELD,1,IDXID,0)
 . S IDXTYP=$P(IDXINF,"^",3)
 . I IDXTYP="",'$D(FDINF("IDX")) S FDINF("IDX")=$P(^DD(FILE,FIELD,1,IDXID,0),"^",2) Q
 . Q:IDXTYP'="TRIGGER"
 . S TRIGFILE=$P(IDXINF,"^",4)
 . S TRIGFLD=$P(IDXINF,"^",5)
 . S TRIGPRED=$$FIELDTOPRED(TRIGFLD)
 . Q:TRIGPRED=""  ; file or field must be invalid
 . I $D(FDINF("TRIGS")) S FDINF("TRIGS")=FDINF("TRIGS")_","
 . E  S FDINF("TRIGS")=""
 . S FDINF("TRIGS")=FDINF("TRIGS")_TRIGFILE_"/"_TRIGPRED
 Q
 ;
 ;
 ; Get External Value - QA's IVAL against FDINF and returns EVAL which
 ; could be the same.
 ;
 ; TBD:
 ; - distinguish fall back EVAL (=IVAL) from error EVAL ie/ resolution error
 ; - GETS maps some .01's (50_605 to field 1 etc.) Is this in meta or ?
 ; Another ex is 120_8 Allergy Type is a 4 but treated like a CODE. Ext form
 ; comes from ^DD(120.8,3.1,2.1)="S Y=$$OUTTYPE^GMRAUTL(Y)" [this doesn't work
 ; for lab's name map.]
 ; - catch the invalid - CODES beyond range, bad ptrs, dates etc.
 ;
GETEVAL(FDINF,IVAL,BAD) ;
 Q:$D(FDINF("HIDE")) "**HIDDEN**"
 N EVAL S EVAL=IVAL  ; Fallback to internal value (may be prob for set of codes?)
 I FDINF("TYPE")=1  D
 . S EVAL=$$MAKEXMLDATE^FMQLUTIL(IVAL) 
 . S:EVAL=-1 BAD(FDINF("TYPE"),"BAD DATE")=""
 I (FDINF("TYPE")=3)!(FDINF("TYPE")=12)  D
 . I '$D(FDINF("CODES",IVAL)) S BAD(FDINF("TYPE"),"NO IVAL MAP")="" Q
 . S EVAL=$S(FDINF("TYPE")=12:FDINF("CODES",IVAL),1:IVAL_":"_FDINF("CODES",IVAL))
 I FDINF("TYPE")=7 D
 . I IVAL="0" S BAD(7,0)="" Q  ;  TBD: merge with invalid ptr below and return "" (callers must change)
 . N PFLINF D BLDFLINF(FDINF("PFILE"),.PFLINF,0)
 . I $D(PFLINF("BAD")) S BAD(7,PFLINF("BAD"))="" Q
 . N PFDINF D BLDFDINF(.PFLINF,.01,.PFDINF)
 . I $D(PFDINF("BAD")) S BAD(7,PFDINF("BAD"))="" Q
 . I $G(@PFLINF("ARRAY")@(IVAL,0))="" S BAD(7,"REF 0")="" Q  ; Invalid Pointer
 . S IVAL=$P(@PFLINF("ARRAY")@(IVAL,0),"^")
 . I IVAL="" S BAD(7,"REF VAL")="" Q
 . S EVAL=$$GETEVAL(.PFDINF,IVAL,.BAD)
 ; VPTR very like PTR - once PFILE is know.
 I FDINF("TYPE")=8 D
 . N PLOC S PLOC="^"_$P(IVAL,";",2)
 . I '$D(FDINF("PLOC",PLOC)) S BAD(8,"PLOC")="" Q  ; TBD: catch the buggy ptr instead
 . N PFILE S PFILE=FDINF("PLOC",PLOC)
 . N PFLINF D BLDFLINF(PFILE,.PFLINF,0)
 . I $D(PFLINF("BAD")) S BAD(8,PFLINF("BAD"))="" Q
 . N PID S PID=$P(IVAL,";")
 . I PID="" S BAD(8,"NO PID")="" Q  ; Only saw in C***
 . I $G(@PFLINF("ARRAY")@(PID,0))="" S BAD(8,"INVALID POINTER")="" Q  ; Invalid Pointer
 . N PFDINF D BLDFDINF(.PFLINF,.01,.PFDINF)
 . I $D(PFDINF("BAD")) S BAD(8,PFDINF("BAD"))="" Q
 . N PIVAL S PIVAL=$P(@PFLINF("ARRAY")@(PID,0),"^")
 . I PIVAL="" S BAD(8,"REF VAL")="" Q
 . S EVAL=$$GETEVAL(.PFDINF,PIVAL,.BAD)
 Q EVAL
 ;
 ;
 ; Parse URL
 ; TBD: CNode - S PFILE=$G(^DD(FILE,0,"UP")) Q:'PFILE . Without this
 ; can't do recursive INs or DESCRIBE ONE of CNode.
 ; 
PARSEURL(URL,FLINF,ID) ;
 N FILE S FILE=$P(URL,"-")
 D BLDFLINF(FILE,.FLINF,0)
 I $D(FLINF("BAD")) Q
 S ID=$P(URL,"-",2) ; TBD: support CNode Identification
 Q
 ;
 ;
 ; Form: YYMMDD.HHMMSS but no trailing 0's ie 3 not 03 for hour if no minutes
 ;
 ; Note: using FMADD^XLFDT to add a day for YYMMDD.240000 to get xsd compatible
 ; YYMMDD+1.000000
 ;
 ; In comparison with FMTHL7^XLFDT which may replace this
 ; if defined (VISTA and not C***)
 ; ... value for FMTHL7^XLFDT and not this are given in ()
 ; 318, 3181, 31801, 318011 -> -1 (ie/ no only YYYY or YYYYMM)
 ; 3180101 -> 2018-01-01
 ; 3180101.1 -> 2018-01-01T10:00:00
 ; 3180101.01 -> 2018-01-01T01:00:00
 ; 3180101.011 -> 2018-01-01T01:10:00
 ; 3180101.0110066 -> extra 6 will be ignored by both
 ; 3180101.016 -> 2018-01-01T01:60:00 - both in error
 ;
 ; 3171231.24 -> 2018-01-01T00:00:00 - FM goes to 24:00:00 but UTC wants day on
 ;
 ; Must decide to [1] move over [2] also support < full days
 ; and will get TZ (must make sure correct)
 ;
MAKEXMLDATE(FMDATE) ;
 N XMLDATE
 Q:$L(FMDATE)<7 -1
 N YMD S YMD=$P(FMDATE,".",1)
 N HMS S HMS=$P(FMDATE,".",2)
 I HMS=24&($L($T(FMADD^XLFDT))) S YMD=$$FMADD^XLFDT(YMD,1),HMS="000000"
 S XMLDATE=(+$E(YMD,1,3)+1700)
 ; Q:$L(YMD)<4 XMLDATE - old allowed just YYYY
 S XMLDATE=XMLDATE_"-"_$S($E(YMD,5)="":"0"_$E(YMD,4),1:$E(YMD,4,5))
 ; Q:$L(YMD)<6 XMLDATE - old allowed just YYYYMM
 S XMLDATE=XMLDATE_"-"_$S($E(YMD,7)="":"0"_$E(YMD,6),1:$E(YMD,6,7))
 ; Now HHMMSS with complication that trailing odd number <=> \d0, not 0\d
 I HMS="" Q XMLDATE
 S HMS=$E(HMS_"000000",1,7)
 S XMLDATE=XMLDATE_"T"_$E(HMS,1,2)_":"_$E(HMS,3,4)_":"_$E(HMS,5,6)
 Q XMLDATE
 ;
 ;
 ; XMLDATE: YYYY-MM-DDTHH:MM:SS
 ; Note: over current RPC, will be YYYY-MM-DDTHH-MM-SS but
 ; behaves the same as not validating separators below.
 ; TBD: validate date contents correct (see X ^DD(DD) etc)
 ; Possible Issue: 2010-02 -> ...2, not ...02 in FileMan. 
 ; There may be month-only dates in FileMan and in this case,
 ; 3102 ie/ first month of 2010 will be less (numerically)
 ; than 310100. But month-wise it is more. In effect, month
 ; only or year only dates need per file example handling.
 ;
MAKEFMDATE(XMLDATE) ;
 N FMDATE
 ; If missing month or day, then pad with 0s
 S FMDATE=(+$E(XMLDATE,1,4)-1700)
 Q:$L(XMLDATE)<7 FMDATE_"0000"
 S FMDATE=FMDATE_$E(XMLDATE,6,7)
 Q:$L(XMLDATE)<10 FMDATE_"00"
 S FMDATE=FMDATE_$E(XMLDATE,9,10)
 Q:$E(XMLDATE,11)'="T" FMDATE
 S FMDATE=FMDATE_"."
 ; If trailing info missing, ok as $E returns "". 
 ; Does mean will accept 3 for 03 which isn't correct XML
 S FMDATE=FMDATE_$E(XMLDATE,12,13)
 S FMDATE=FMDATE_$E(XMLDATE,15,16)
 S FMDATE=FMDATE_$E(XMLDATE,18,19)
 Q FMDATE
 ;
 ;
 ; Predicate is lower alphanum and _
 ; ... called from JSON over and over ie/ not in DATA or SCH where it should be
 ;
FIELDTOPRED(FIELD) ;
 SET ALW="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ /"
 SET UPC="ABCDEFGHIJKLMNOPQRSTUVWXYZ /"
 SET LOC="abcdefghijklmnopqrstuvwxyz__"
 N PRED S PRED=$TR($TR(FIELD,$TR(FIELD,ALW)),UPC,LOC)
 Q PRED
 ;
]]></Routine>

</Export>
